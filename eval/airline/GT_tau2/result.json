{
  "domain": {
    "app_name": "airline",
    "toolguard_common": {
      "file_name": "rt_toolguard/data_types.py",
      "content": "from abc import ABC, abstractmethod\nimport os\nfrom pathlib import Path\nfrom pydantic import BaseModel, Field\nfrom typing import Any, List, Optional\n\nDEBUG_DIR = \"debug\"\nTESTS_DIR = \"tests\"\nRESULTS_FILENAME = \"result.json\"\nHISTORY_PARAM = \"history\"\nHISTORY_PARAM_TYPE = \"ChatHistory\"\nAPI_PARAM = \"api\"\n\nclass FileTwin(BaseModel):\n    file_name: str\n    content: str\n\n    def save(self, folder:str)->'FileTwin':\n        full_path = os.path.join(folder, self.file_name)\n        parent = Path(full_path).parent\n        os.makedirs(parent, exist_ok=True)\n        with open(full_path, \"w\") as file:\n            file.write(self.content)\n        return self\n\n    def save_as(self, folder:str, file_name:str)->'FileTwin':\n        file_path = os.path.join(folder, file_name)\n        with open(file_path, \"w\") as file:\n            file.write(self.content)\n        return FileTwin(file_name=file_name, content=self.content)\n\n    @staticmethod\n    def load_from(folder:str, file_path:str)->'FileTwin':\n        with open(os.path.join(folder, file_path), \"r\") as file:\n            data = file.read()\n            return FileTwin(\n                file_name=file_path, \n                content=data\n            )\n\nclass ToolPolicyItem(BaseModel):\n    name: str = Field(..., description=\"Policy item name\")\n    description: str = Field(..., description=\"Policy item description\")\n    references: List[str] = Field(..., description=\"original texts\")\n    compliance_examples: Optional[List[str]] = Field(..., description=\"Example of cases that comply with the policy\")\n    violation_examples: Optional[List[str]] = Field(..., description=\"Example of cases that violate the policy\")\n\n    def to_md_bulltets(self, items: List[str])->str:\n        s = \"\"\n        for item in items:\n            s+=f\"* {item}\\n\"\n        return s\n    \n    def __str__(self) -> str:\n        s = f\"#### Policy item \" + self.name + \"\\n\"\n        s += f\"{self.description}\\n\"\n        if self.compliance_examples:\n            s += f\"##### Positive examples\\n{self.to_md_bulltets(self.compliance_examples)}\"\n        if self.violation_examples:\n            s += f\"##### Negative examples\\n{self.to_md_bulltets(self.violation_examples)}\"\n        return s\n\nclass ToolPolicy(BaseModel):\n    tool_name: str = Field(..., description=\"Name of the tool\")\n    policy_items: List[ToolPolicyItem] = Field(..., description=\"Policy items. All (And logic) policy items must hold whehn invoking the tool.\")\n\nclass Domain(BaseModel):\n    app_name: str = Field(..., description=\"Application name\")\n    toolguard_common: FileTwin = Field(..., description=\"Pydantic data types used by toolguard framework.\")\n    app_types: FileTwin = Field(..., description=\"Data types defined used in the application API as payloads.\")\n    app_api_class_name: str = Field(..., description=\"Name of the API class name.\")\n    app_api: FileTwin = Field(..., description=\"Python class (abstract) containing all the API signatures.\")\n    app_api_size: int = Field(..., description=\"Number of functions in the API\")\n\nclass RuntimeDomain(Domain):\n    app_api_impl_class_name: str = Field(..., description=\"Python class (implementaton) class name.\")\n    app_api_impl: FileTwin = Field(..., description=\"Python class containing all the API method implementations.\")\n\nclass ChatHistory(ABC):\n    \"\"\"Represents a history of chat messages and provides methods check if specific events already happened.\"\"\"\n\n    @abstractmethod\n    def ask_bool(self, question:str)->bool:\n        \"\"\"\n        Asks a yes/no question and returns the response as a boolean.\n\n        Args:\n            question (str): The yes/no question to be asked. Example: \"Did the user accepted the agent's proposal?\"\n\n        Returns:\n            bool: The interpreted boolean response from the language model.\n        \"\"\"\n        pass\n    \n    @abstractmethod\n    def did_tool_return_value(self, tool_name:str, expected_value:Any)->bool:\n        \"\"\"\n        Checks whether a specific tool was called in the chat history and validates if the expected value was returned\n            Example: \"did_tool_return_value(\"book_hotel\",True) checks if the history shows calling the function book_hotel and if the returned value was true did_tool_return_value will return true else false\n        \n        Args:\n            tool_name (str): The name of the tool to check for in the message history.\n            expected_value: The expected value of the tool call.\n        \n        Returns:\n            bool: True if the tool was called returning expected_value, False otherwise.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def was_tool_called(self, tool_name: str) -> bool:\n        \"\"\"\n        Checks whether a specific tool was called in the chat history.\n\t\tArgs:\n\t\t\ttool_name (str): The name of the tool to check for in the message history.\n\t\tReturns:\n\t\t\tbool: True if the tool was called, False otherwise.\n\t\t\"\"\"\n        pass\n\n\nclass PolicyViolationException(Exception):\n    _msg: str\n    def __init__(self, message:str):\n        super().__init__(message)\n        self._msg = message\n\n    @property\n    def message(self):\n        return self._msg\n"
    },
    "app_types": {
      "file_name": "airline/airline_types.py",
      "content": "# Auto-generated type definitions\nfrom enum import Enum\nfrom abc import ABC\nfrom typing import *\nfrom pydantic import BaseModel, Field\n\nclass Passenger(BaseModel):\n    first_name: str  # Passenger's first name\n    last_name: str  # Passenger's last name\n    dob: str  # Date of birth in YYYY-MM-DD format\n\nclass FlightDataStatusFlying(BaseModel):\n    status: Literal['flying']  # Indicates flight is in flight\n    actual_departure_time_est: str  # Actual departure time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T06:04:00\n    estimated_arrival_time_est: str  # Estimated arrival time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T07:30:00\n\nclass FlightDateStatusAvailable(BaseModel):\n    status: Literal['available']  # Indicates flight is available for booking\n    available_seats: dict[Literal['business', 'economy', 'basic_economy'], int]  # Available seats by class\n    prices: dict[Literal['business', 'economy', 'basic_economy'], int]  # Current prices by class\n\nclass Name(BaseModel):\n    first_name: str  # The person's first name\n    last_name: str  # The person's last name\n\nclass FlightDataStatusOnTime(BaseModel):\n    status: Literal['on time']  # Indicates flight is on time\n    estimated_departure_time_est: str  # Estimated departure time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T06:04:00\n    estimated_arrival_time_est: str  # Estimated arrival time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T07:30:00\n\nclass FlightDateStatusLanded(BaseModel):\n    status: Literal['landed']  # Indicates flight has landed\n    actual_departure_time_est: str  # Actual departure time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T06:04:00\n    actual_arrival_time_est: str  # Actual arrival time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T07:30:00\n\nclass FlightDateStatusCancelled(BaseModel):\n    status: Literal['cancelled']  # Indicates flight was cancelled\n\nclass FlightBase(BaseModel):\n    flight_number: str  # Unique flight identifier\n    origin: str  # IATA code for origin airport\n    destination: str  # IATA code for destination airport\n\nclass AirportCode(BaseModel):\n    iata: str  # IATA code\n    city: str  # City name\n\nclass Address(BaseModel):\n    address1: str  # Primary address line\n    address2: Optional[str]  # Secondary address line (optional)\n    city: str  # City name\n    country: str  # Country name\n    state: str  # State or province name\n    zip: str  # Postal code\n\nclass FlightDateStatusDelayed(BaseModel):\n    status: Literal['delayed']  # Indicates flight was delayed\n    estimated_departure_time_est: str  # Estimated departure time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T06:04:00\n    estimated_arrival_time_est: str  # Estimated arrival time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T07:30:00\n\nclass PaymentMethodBase(BaseModel):\n    source: str  # Type of payment method\n    id: str  # Unique identifier for the payment method\n\nclass FlightInfo(BaseModel):\n    flight_number: str  # Flight number, such as 'HAT001'.\n    date: str  # The date for the flight in the format 'YYYY-MM-DD', such as '2024-05-01'.\n\nclass Payment(BaseModel):\n    payment_id: str  # Unique identifier for the payment\n    amount: int  # Payment amount in dollars\n\nclass DirectFlight(FlightBase):\n    status: Literal['available']  # Indicates flight is available for booking\n    scheduled_departure_time_est: str  # Scheduled departure time in EST in the format HH:MM:SS, e.g 06:00:00\n    scheduled_arrival_time_est: str  # Scheduled arrival time in EST in the format HH:MM:SS, e.g 07:00:00\n    date: Optional[str]  # Flight date in YYYY-MM-DD format\n    available_seats: dict[Literal['business', 'economy', 'basic_economy'], int]  # Available seats by class\n    prices: dict[Literal['business', 'economy', 'basic_economy'], int]  # Current prices by class\n\nclass ReservationFlight(FlightBase):\n    date: str  # Flight date in YYYY-MM-DD format\n    price: int  # Flight price in dollars.\n\nclass Flight(FlightBase):\n    scheduled_departure_time_est: str  # Scheduled departure time in EST in the format HH:MM:SS, e.g 06:00:00\n    scheduled_arrival_time_est: str  # Scheduled arrival time in EST in the format HH:MM:SS, e.g 07:00:00\n    dates: dict[str, Union[FlightDateStatusAvailable, FlightDateStatusLanded, FlightDateStatusCancelled, FlightDateStatusDelayed, FlightDataStatusFlying, FlightDataStatusOnTime]]  # Flight status by date (YYYY-MM-DD)\n\nclass GiftCard(PaymentMethodBase):\n    source: Literal['gift_card']  # Indicates this is a gift card payment method\n    amount: float  # Gift card value amount\n    id: str  # Unique identifier for the gift card\n\nclass Certificate(PaymentMethodBase):\n    source: Literal['certificate']  # Indicates this is a certificate payment method\n    amount: float  # Certificate value amount\n\nclass CreditCard(PaymentMethodBase):\n    source: Literal['credit_card']  # Indicates this is a credit card payment method\n    brand: str  # Credit card brand (e.g., visa, mastercard)\n    last_four: str  # Last four digits of the credit card\n\nclass Reservation(BaseModel):\n    reservation_id: str  # Unique identifier for the reservation\n    user_id: str  # ID of the user who made the reservation\n    origin: str  # IATA code for trip origin\n    destination: str  # IATA code for trip destination\n    flight_type: Literal['round_trip', 'one_way']  # Type of trip\n    cabin: Literal['business', 'economy', 'basic_economy']  # Selected cabin class\n    flights: list[ReservationFlight]  # List of flights in the reservation\n    passengers: list[Passenger]  # List of passengers on the reservation\n    payment_history: list[Payment]  # History of payments for this reservation\n    created_at: str  # Timestamp when reservation was created in the format YYYY-MM-DDTHH:MM:SS\n    total_baggages: int  # Total number of bags in reservation\n    nonfree_baggages: int  # Number of paid bags in reservation\n    insurance: Literal['yes', 'no']  # Whether travel insurance was purchased\n    status: Optional[Literal['cancelled']]  # Status of the reservation\n\nclass User(BaseModel):\n    user_id: str  # Unique identifier for the user\n    name: Name  # User's full name\n    address: Address  # User's address information\n    email: str  # User's email address\n    dob: str  # User's date of birth in the format YYYY-MM-DD, e.g 1990-04-05\n    payment_methods: dict[str, Union[CreditCard, GiftCard, Certificate]]  # User's saved payment methods\n    saved_passengers: list[Passenger]  # User's saved passenger information\n    membership: Literal['gold', 'silver', 'regular']  # User's membership level\n    reservations: list[str]  # List of user's reservation IDs\n"
    },
    "app_api_class_name": "I_Airline",
    "app_api": {
      "file_name": "airline/i_airline.py",
      "content": "# Auto-generated class interface\nfrom typing import * # type: ignore\nfrom abc import ABC, abstractmethod\nfrom airline.airline_types import *\n\nclass I_Airline(ABC):\n\n    @abstractmethod\n    def book_reservation(self, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo| dict], passengers: list[Passenger| dict], payment_methods: list[Payment| dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']) -> Reservation:\n        \"\"\"\n        Book a reservation.\n        \n        Args:\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'`.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def calculate(self, expression: str) -> str:\n        \"\"\"\n        Calculate the result of a mathematical expression.\n        \n        Args:\n        expression: The mathematical expression to calculate, such as '2 + 2'. The expression can contain numbers, operators (+, -, *, /), parentheses, and spaces.\n        \n        Returns:\n        The result of the mathematical expression.\n        \n        Raises:\n        ValueError: If the expression is invalid.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def cancel_reservation(self, reservation_id: str) -> Reservation:\n        \"\"\"\n        Cancel the whole reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get_flight_instance(self, flight_number: str, date: str) -> Union[FlightDateStatusAvailable, FlightDateStatusLanded, FlightDateStatusCancelled, FlightDateStatusDelayed, FlightDataStatusFlying, FlightDataStatusOnTime]:\n        \"\"\"\n        Get the flight.\n        \n        Args:\n        flight_number: The flight number.\n        date: The date of the flight.\n        \n        Returns:\n        The flight.\n        \n        Raises:\n        ValueError: If the flight is not found.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get_flight_status(self, flight_number: str, date: str) -> Literal['available', 'on time', 'flying', 'cancelled', 'delayed', 'landed']:\n        \"\"\"\n        Get the status of a flight.\n        \n        Args:\n        flight_number: The flight number.\n        date: The date of the flight.\n        \n        Returns:\n        The status of the flight.\n        \n        Raises:\n        ValueError: If the flight is not found.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get_reservation_details(self, reservation_id: str) -> Reservation:\n        \"\"\"\n        Get the details of a reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as '8JX2WO'.\n        \n        Returns:\n        The reservation details.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get_scheduled_flight(self, flight_number: str) -> Flight:\n        \"\"\"\n        Get the flight schedule.\n        \n        Args:\n        flight_number: The flight number.\n        \n        Returns:\n        The flight schedule\n        \n        Raises:\n        ValueError: If the flight is not found.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get_user_details(self, user_id: str) -> User:\n        \"\"\"\n        Get the details of a user, including their reservations.\n        \n        Args:\n        user_id: The user ID, such as 'sara_doe_496'.\n        \n        Returns:\n        The user details.\n        \n        Raises:\n        ValueError: If the user is not found.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def list_all_airports(self) -> list[AirportCode]:\n        \"\"\"\n        Returns a list of all available airports.\n        \n        Returns:\n        A dictionary mapping IATA codes to AirportInfo objects.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def search_direct_flight(self, origin: str, destination: str, date: str) -> list[DirectFlight]:\n        \"\"\"\n        Search for direct flights between two cities on a specific date.\n        \n        Args:\n        origin: The origin city airport in three letters, such as 'JFK'.\n        destination: The destination city airport in three letters, such as 'LAX'.\n        date: The date of the flight in the format 'YYYY-MM-DD', such as '2024-01-01'.\n        \n        Returns:\n        The direct flights between the two cities on the specific date.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def search_onestop_flight(self, origin: str, destination: str, date: str) -> list[tuple[DirectFlight, DirectFlight]]:\n        \"\"\"\n        Search for one-stop flights between two cities on a specific date.\n        \n        Args:\n        origin: The origin city airport in three letters, such as 'JFK'.\n        destination: The destination city airport in three letters, such as 'LAX'.\n        date: The date of the flight in the format 'YYYY-MM-DD', such as '2024-05-01'.\n        \n        Returns:\n        A list of pairs of DirectFlight objects.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def send_certificate(self, user_id: str, amount: int) -> str:\n        \"\"\"\n        Send a certificate to a user. Be careful!\n        \n        Args:\n        user_id: The ID of the user to book the reservation, such as 'sara_doe_496'.\n        amount: The amount of the certificate to send.\n        \n        Returns:\n        A message indicating the certificate was sent.\n        \n        Raises:\n        ValueError: If the user is not found.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def transfer_to_human_agents(self, summary: str) -> str:\n        \"\"\"\n        Transfer the user to a human agent, with a summary of the user's issue.\n        Only transfer if\n        -  the user explicitly asks for a human agent\n        -  given the policy and the available tools, you cannot solve the user's issue.\n        \n        Args:\n        summary: A summary of the user's issue.\n        \n        Returns:\n        A message indicating the user has been transferred to a human agent.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def update_reservation_baggages(self, reservation_id: str, total_baggages: int, nonfree_baggages: int, payment_id: str) -> Reservation:\n        \"\"\"\n        Update the baggage information of a reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'\n        total_baggages: The updated total number of baggage items included in the reservation.\n        nonfree_baggages: The updated number of non-free baggage items included in the reservation.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        ValueError: If the user is not found.\n        ValueError: If the payment method is not found.\n        ValueError: If the certificate cannot be used to update reservation.\n        ValueError: If the gift card balance is not enough.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def update_reservation_flights(self, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo| dict], payment_id: str) -> Reservation:\n        \"\"\"\n        Update the flight information of a reservation.\n        \n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        ValueError: If the user is not found.\n        ValueError: If the payment method is not found.\n        ValueError: If the certificate cannot be used to update reservation.\n        ValueError: If the gift card balance is not enough.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def update_reservation_passengers(self, reservation_id: str, passengers: list[Passenger| dict]) -> Reservation:\n        \"\"\"\n        Update the passenger information of a reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        passengers: An array of objects containing details about each passenger.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        ValueError: If the number of passengers does not match.\n        \"\"\"\n        ...\n"
    },
    "app_api_size": 16,
    "app_api_impl_class_name": "Airlineimpl",
    "app_api_impl": {
      "file_name": "airline/airline_impl.py",
      "content": "# Auto-generated class\nfrom typing import *\nfrom airline.i_airline import I_Airline\nfrom airline.airline_types import *\n\nclass Airlineimpl(I_Airline):\n\n    def __init__(self, delegate: I_Airline):\n        self._delegate = delegate\n    \n    def book_reservation(self, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo| dict], passengers: list[Passenger| dict], payment_methods: list[Payment| dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']) -> Reservation:\n        \"\"\"\n        Book a reservation.\n        \n        Args:\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'`.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n        \"\"\"\n\n        return self._delegate.book_reservation(user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n\n\n    def calculate(self, expression: str) -> str:\n        \"\"\"\n        Calculate the result of a mathematical expression.\n        \n        Args:\n        expression: The mathematical expression to calculate, such as '2 + 2'. The expression can contain numbers, operators (+, -, *, /), parentheses, and spaces.\n        \n        Returns:\n        The result of the mathematical expression.\n        \n        Raises:\n        ValueError: If the expression is invalid.\n        \"\"\"\n\n        return self._delegate.calculate(expression)\n\n\n    def cancel_reservation(self, reservation_id: str) -> Reservation:\n        \"\"\"\n        Cancel the whole reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        \"\"\"\n\n        return self._delegate.cancel_reservation(reservation_id)\n\n\n    def get_flight_instance(self, flight_number: str, date: str) -> Union[FlightDateStatusAvailable, FlightDateStatusLanded, FlightDateStatusCancelled, FlightDateStatusDelayed, FlightDataStatusFlying, FlightDataStatusOnTime]:\n        \"\"\"\n        Get the flight.\n        \n        Args:\n        flight_number: The flight number.\n        date: The date of the flight.\n        \n        Returns:\n        The flight.\n        \n        Raises:\n        ValueError: If the flight is not found.\n        \"\"\"\n\n        return self._delegate.get_flight_instance(flight_number, date)\n\n\n    def get_flight_status(self, flight_number: str, date: str) -> Literal['available', 'on time', 'flying', 'cancelled', 'delayed', 'landed']:\n        \"\"\"\n        Get the status of a flight.\n        \n        Args:\n        flight_number: The flight number.\n        date: The date of the flight.\n        \n        Returns:\n        The status of the flight.\n        \n        Raises:\n        ValueError: If the flight is not found.\n        \"\"\"\n\n        return self._delegate.get_flight_status(flight_number, date)\n\n\n    def get_reservation_details(self, reservation_id: str) -> Reservation:\n        \"\"\"\n        Get the details of a reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as '8JX2WO'.\n        \n        Returns:\n        The reservation details.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        \"\"\"\n\n        return self._delegate.get_reservation_details(reservation_id)\n\n\n    def get_scheduled_flight(self, flight_number: str) -> Flight:\n        \"\"\"\n        Get the flight schedule.\n        \n        Args:\n        flight_number: The flight number.\n        \n        Returns:\n        The flight schedule\n        \n        Raises:\n        ValueError: If the flight is not found.\n        \"\"\"\n\n        return self._delegate.get_scheduled_flight(flight_number)\n\n\n    def get_user_details(self, user_id: str) -> User:\n        \"\"\"\n        Get the details of a user, including their reservations.\n        \n        Args:\n        user_id: The user ID, such as 'sara_doe_496'.\n        \n        Returns:\n        The user details.\n        \n        Raises:\n        ValueError: If the user is not found.\n        \"\"\"\n\n        return self._delegate.get_user_details(user_id)\n\n\n    def list_all_airports(self) -> list[AirportCode]:\n        \"\"\"\n        Returns a list of all available airports.\n        \n        Returns:\n        A dictionary mapping IATA codes to AirportInfo objects.\n        \"\"\"\n\n        return self._delegate.list_all_airports()\n\n\n    def search_direct_flight(self, origin: str, destination: str, date: str) -> list[DirectFlight]:\n        \"\"\"\n        Search for direct flights between two cities on a specific date.\n        \n        Args:\n        origin: The origin city airport in three letters, such as 'JFK'.\n        destination: The destination city airport in three letters, such as 'LAX'.\n        date: The date of the flight in the format 'YYYY-MM-DD', such as '2024-01-01'.\n        \n        Returns:\n        The direct flights between the two cities on the specific date.\n        \"\"\"\n\n        return self._delegate.search_direct_flight(origin, destination, date)\n\n\n    def search_onestop_flight(self, origin: str, destination: str, date: str) -> list[tuple[DirectFlight, DirectFlight]]:\n        \"\"\"\n        Search for one-stop flights between two cities on a specific date.\n        \n        Args:\n        origin: The origin city airport in three letters, such as 'JFK'.\n        destination: The destination city airport in three letters, such as 'LAX'.\n        date: The date of the flight in the format 'YYYY-MM-DD', such as '2024-05-01'.\n        \n        Returns:\n        A list of pairs of DirectFlight objects.\n        \"\"\"\n\n        return self._delegate.search_onestop_flight(origin, destination, date)\n\n\n    def send_certificate(self, user_id: str, amount: int) -> str:\n        \"\"\"\n        Send a certificate to a user. Be careful!\n        \n        Args:\n        user_id: The ID of the user to book the reservation, such as 'sara_doe_496'.\n        amount: The amount of the certificate to send.\n        \n        Returns:\n        A message indicating the certificate was sent.\n        \n        Raises:\n        ValueError: If the user is not found.\n        \"\"\"\n\n        return self._delegate.send_certificate(user_id, amount)\n\n\n    def transfer_to_human_agents(self, summary: str) -> str:\n        \"\"\"\n        Transfer the user to a human agent, with a summary of the user's issue.\n        Only transfer if\n        -  the user explicitly asks for a human agent\n        -  given the policy and the available tools, you cannot solve the user's issue.\n        \n        Args:\n        summary: A summary of the user's issue.\n        \n        Returns:\n        A message indicating the user has been transferred to a human agent.\n        \"\"\"\n\n        return self._delegate.transfer_to_human_agents(summary)\n\n\n    def update_reservation_baggages(self, reservation_id: str, total_baggages: int, nonfree_baggages: int, payment_id: str) -> Reservation:\n        \"\"\"\n        Update the baggage information of a reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'\n        total_baggages: The updated total number of baggage items included in the reservation.\n        nonfree_baggages: The updated number of non-free baggage items included in the reservation.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        ValueError: If the user is not found.\n        ValueError: If the payment method is not found.\n        ValueError: If the certificate cannot be used to update reservation.\n        ValueError: If the gift card balance is not enough.\n        \"\"\"\n\n        return self._delegate.update_reservation_baggages(reservation_id, total_baggages, nonfree_baggages, payment_id)\n\n\n    def update_reservation_flights(self, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo| dict], payment_id: str) -> Reservation:\n        \"\"\"\n        Update the flight information of a reservation.\n        \n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        ValueError: If the user is not found.\n        ValueError: If the payment method is not found.\n        ValueError: If the certificate cannot be used to update reservation.\n        ValueError: If the gift card balance is not enough.\n        \"\"\"\n\n        return self._delegate.update_reservation_flights(reservation_id, cabin, flights, payment_id)\n\n\n    def update_reservation_passengers(self, reservation_id: str, passengers: list[Passenger| dict]) -> Reservation:\n        \"\"\"\n        Update the passenger information of a reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        passengers: An array of objects containing details about each passenger.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        ValueError: If the number of passengers does not match.\n        \"\"\"\n\n        return self._delegate.update_reservation_passengers(reservation_id, passengers)\n\n"
    }
  },
  "tools": {
    "book_reservation": {
      "tool": {
        "tool_name": "book_reservation",
        "policy_items": [
          {
            "name": "User ID and User Profile Verification",
            "description": "Before invoking ToolX (BookReservation), make sure that the user's ID is correctly obtained. After verifying the user ID, gather necessary booking information such as trip type, origin, and destination prior to making the reservation using ToolX.",
            "references": [
              "The agent must first obtain the user id, then ask for the trip type, origin, destination."
            ],
            "compliance_examples": [
              "An agent receives a user request to book a flight, first verifies the user's ID exists in the system records, and subsequently collects information on trip type, origin, and destination before proceeding with BookReservation."
            ],
            "violation_examples": [
              "The agent attempts to use BookReservation but enters an incorrect user ID that does not exist in the system records.",
              "After obtaining the user ID, the agent makes a call to BookReservation without confirming the trip type, thereby not gathering necessary booking information.",
              "Upon receiving an ID query from a user, the agent assumes the ID is correct without verifying it against system records and proceeds to book a reservation, breaching the mandate for ID confirmation."
            ]
          },
          {
            "name": "Flight Status Restrictions",
            "description": "Flights chosen for booking using ToolX must have the status 'available' to ensure that they have not taken off. Flights with status 'delayed', 'on time', or 'flying' cannot be booked.",
            "references": [
              "If the status is \"available\", the flight has not taken off",
              "If the status is \"delayed\" or \"on time\", the flight has not taken off, cannot be booked.",
              "If the status is \"flying\", the flight has taken off but not landed, cannot be booked."
            ],
            "compliance_examples": [
              "A user requests to book a flight from SFO to LAX on June 20th. The agent checks the flight information and confirms that the flight status is 'available' before proceeding with the booking using the BookReservation tool.",
              "Before booking a round-trip flight for two passengers in economy class, the agent verifies all flights' statuses are 'available' and there are two seats available for this class."
            ],
            "violation_examples": [
              "A user attempts to book a flight to New York on May 16th using the BookReservation tool. However, the flight status indicates 'delayed'.",
              "An agent tries to book a reservation for a user on flight HAT007 from ATL to MIA. The API checks reveal that the flight's status is currently 'flying'.",
              "A reservation request is made for a flight with the status 'on time'.",
              "An agent attempts to book a round-trip from LAX to DFW for a user, but the departure flight's status is 'on time' which is not permissible as per the policy that only allows booking flights with 'available' status.",
              "A reservation is attempted for a flight where the status is 'cancelled'. Despite knowing that only flights with 'available' status can be booked, the agent proceeds, resulting in a policy breach.",
              "A user attempts to make a reservation with two flights. The first one's status is 'delayed', and the second one is 'available'.",
              "A user attempts to make a reservation with two flights. The first one's status is 'available', and the second one is 'delayed'."
            ]
          },
          {
            "name": "Seats Are Available",
            "description": "Flights chosen for booking must have enough available seats for all passengers, and prices listed for booking.",
            "references": [
              "If the status is \"available\", the flight has not taken off, available seats and prices are listed."
            ],
            "compliance_examples": [
              "A user requests to book a flight from SFO to LAX on June 20th in economy class. The flight status is 'available' and there are 21 available seats",
              "A user is booking a round-trip flight from SFO to LAX, for two passengers in economy class. There are enough availble seats in the two flights"
            ],
            "violation_examples": [
              "A user attempts to book a flight to New York on May 16th for 5 passengers in business class, however only 4 seats are available on this flight",
              "An agent attempts to book a round-trip from LAX to DFW for a user in economy cabin, the outgoing flight status is availbale, but the there are no available seat in this cabin",
              "An agent attempts to book a round-trip from LAX to DFW for a user in economy cabin, there are enough seats in the outgoing flight and the flight status is availabile. The return flight status is availbale, but the there are no available seat in this cabin"
            ]
          },
          {
            "name": "Passenger Information Completeness",
            "description": "Ensure all required passenger details are collected. Limit to five passengers per reservation, with details including first name, last name, and date of birth.",
            "references": [
              "Passengers: Each reservation can have at most five passengers. The agent needs to collect the first name, last name, and date of birth for each passenger."
            ],
            "compliance_examples": [
              "An agent successfully gathers and verifies all required passenger information including first name, last name, and date of birth for each of the five passengers."
            ],
            "violation_examples": [
              "An agent attempts to book a reservation using BookReservation for six passengers instead of the allowed maximum of five.",
              "An agent calls BookReservation with the passenger details incomplete, missing the date of birth for each passenger.",
              "An agent attempts to book a reservation with no passengers.",
              "Booking a reservation for one passenger with missing first name information.",
              "Booking a reservation for one passenger with missing last name information."
            ]
          },
          {
            "name": "Payment Method Restriction",
            "description": "Ensure each reservation through BookReservation uses a maximum of one travel certificate, one credit card, and up to three gift cards. Verify that all payment methods are pre-registered in the user profile before proceeding with booking to maintain security and database integrity.",
            "references": [
              "Payment: each reservation can use at most one travel certificate, at most one credit card, and at most three gift cards. The remaining amount of a travel certificate is not refundable.",
              "All payment methods must already be in user profile for safety reasons."
            ],
            "compliance_examples": [
              "A reservation is made using a single credit card that is already registered in the user's profile.",
              "The user books a flight using one travel certificate and three gift cards (all pre-registered in their profile).",
              "A user uses one credit card and one gift card that are already stored in their user profile.",
              "A reservation is completed using only two gift cards and no travel certificate or credit card. Both gift cards are pre-existing in the user's profile."
            ],
            "violation_examples": [
              "A user attempts to book a reservation using two credit cards.",
              "During reservation, a user inputs four gift cards.",
              "A user submits a booking request where the payment method includes a travel certificate not listed in the user profile.",
              "A booking attempt is made using a travel certificate, a credit card, and an additional travel certificate for balance.",
              "The booking data included the use of an unverified payment method - a newly added gift card not synced with the user profile.",
              "Upon making a reservation, the user provides payment details for a new credit card that isn't in the user's pre-registered profile list."
            ]
          },
          {
            "name": "Checked Bag Allowance by Membership Tier",
            "description": "The checked bag allowance policy for booking a reservation varies by membership tier and cabin class: 1) Regular members have 0 free checked bags for basic economy, 1 for economy, and 2 for business. 2) Silver members have 1 free checked bag for basic economy, 2 for economy, and 3 for business. 3) Gold members have 2 free checked bags for basic economy, 3 for economy and business. An extra baggage fee of $50 applies for additional luggage.",
            "references": [
              "Checked bag allowance: If the booking user is a regular member, 0 free checked bag for each basic economy passenger, 1 free checked bag for each economy passenger, and 2 free checked bags for each business passenger. If the booking user is a silver member, 1 free checked bag for each basic economy passenger, 2 free checked bag for each economy passenger, and 3 free checked bags for each business passenger. If the booking user is a gold member, 2 free checked bag for each basic economy passenger, 3 free checked bag for each economy passenger, and 3 free checked bags for each business passenger. Each extra baggage is 50 dollars."
            ],
            "compliance_examples": [
              "A regular member books a business class flight with 2 free checked bags for a single passenger.",
              "A gold member books an economy class flight with 3 free checked bags.",
              "A gold member books an economy class flight with 4 checked bags, where he pays for one and the other three are free.",
              "A silver member books a basic economy flight with 2 total checked bags, where 1 is free and 1 incurs a $50 additional fee.",
              "A silver member books a basic economy flight for three passengers asking for 5 bags, and pays for two of them.",
              "A regular member books a basic economy flight journey and opts not to check any free bags.",
              "A gold member books a basic economy flight journey and opts not to check any free bags."
            ],
            "violation_examples": [
              "A regular member books a flight in basic economy class with 1 free checked bag.",
              "A silver member attempts to book an economy class flight with 3 free checked bags.",
              "A gold member books a business class flight with 4 free checked bags.",
              "A silver member with one bag books a basic economy class flight and is charged for his single bag.",
              "A regular member books an economy class flight for one passenger with 2 free and 1 non-free checked bags, without incurring additional charges.",
              "A gold member reserves a basic economy ticket and receives 3 free checked bags.",
              "A gold member reserves a basic economy ticket for two passengers, asking for five free bags in total."
            ]
          }
        ]
      },
      "guard_fn_name": "guard_book_reservation",
      "guard_file": {
        "file_name": "airline/book_reservation/guard_book_reservation.py",
        "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\nfrom airline.book_reservation.guard_user_id_and_user_profile_verification import guard_user_id_and_user_profile_verification\nfrom airline.book_reservation.guard_flight_status_restrictions import guard_flight_status_restrictions\nfrom airline.book_reservation.guard_seats_are_available import guard_seats_are_available\nfrom airline.book_reservation.guard_passenger_information_completeness import guard_passenger_information_completeness\nfrom airline.book_reservation.guard_payment_method_restriction import guard_payment_method_restriction\nfrom airline.book_reservation.guard_checked_bag_allowance_by_membership_tier import guard_checked_bag_allowance_by_membership_tier\n\n\ndef guard_book_reservation(history: ChatHistory, api: I_Airline, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], passengers: list[Passenger | dict], payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Checks that a tool call complies to the policies.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'`.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance. \n    \"\"\"\n    \n    guard_user_id_and_user_profile_verification(history, api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n    guard_flight_status_restrictions(history, api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n    guard_seats_are_available(history, api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n    guard_passenger_information_completeness(history, api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n    guard_payment_method_restriction(history, api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n    guard_checked_bag_allowance_by_membership_tier(history, api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n"
      },
      "item_guard_files": [
        {
          "file_name": "airline/book_reservation/guard_user_id_and_user_profile_verification.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_user_id_and_user_profile_verification(history: ChatHistory, api: I_Airline, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], passengers: list[Passenger | dict], payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Policy to check: Before invoking ToolX (BookReservation), make sure that the user's ID is correctly obtained. After verifying the user ID, gather necessary booking information such as trip type, origin, and destination prior to making the reservation using ToolX.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'`.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/book_reservation/guard_flight_status_restrictions.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_flight_status_restrictions(history: ChatHistory, api: I_Airline, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], passengers: list[Passenger | dict], payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Policy to check: Flights chosen for booking using ToolX must have the status 'available' to ensure that they have not taken off. Flights with status 'delayed', 'on time', or 'flying' cannot be booked.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n    \"\"\"\n    for flight in flights:\n        flight_number = flight['flight_number'] if isinstance(flight, dict) else flight.flight_number\n        date = flight['date'] if isinstance(flight, dict) else flight.date\n        status = api.get_flight_status(flight_number, date)\n        if status not in ['available']:\n            raise PolicyViolationException(f\"Flight {flight_number} on {date} has status '{status}', which cannot be booked.\")"
        },
        {
          "file_name": "airline/book_reservation/guard_seats_are_available.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_seats_are_available(history: ChatHistory, api: I_Airline, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], passengers: list[Passenger | dict], payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Policy to check: Flights chosen for booking must have enough available seats for all passengers, and prices listed for booking.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'`.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/book_reservation/guard_passenger_information_completeness.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_passenger_information_completeness(history: ChatHistory, api: I_Airline, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], passengers: list[Passenger | dict], payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Policy to check: Ensure all required passenger details are collected. Limit to five passengers per reservation, with details including first name, last name, and date of birth.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'`.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/book_reservation/guard_payment_method_restriction.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\nclass PolicyViolationException(Exception):\n    pass\n\ndef guard_payment_method_restriction(history: ChatHistory, api: I_Airline, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], passengers: list[Passenger | dict], payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Policy to check: Ensure each reservation through BookReservation uses a maximum of one travel certificate, one credit card, and up to three gift cards. Verify that all payment methods are pre-registered in the user profile before proceeding with booking to maintain security and database integrity.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n    \"\"\"\n    # Retrieve user details to check pre-registered payment methods\n    user_details = api.get_user_details(user_id)\n    registered_payment_methods = user_details.payment_methods\n\n    # Initialize counters for payment method types\n    certificate_count = 0\n    credit_card_count = 0\n    gift_card_count = 0\n\n    # Check each payment method\n    for payment in payment_methods:\n        if isinstance(payment, Certificate):\n            certificate_count += 1\n            if payment.id not in registered_payment_methods:\n                raise PolicyViolationException(\"Certificate not registered in user profile.\")\n        elif isinstance(payment, CreditCard):\n            credit_card_count += 1\n            if payment.id not in registered_payment_methods:\n                raise PolicyViolationException(\"Credit card not registered in user profile.\")\n        elif isinstance(payment, GiftCard):\n            gift_card_count += 1\n            if payment.id not in registered_payment_methods:\n                raise PolicyViolationException(\"Gift card not registered in user profile.\")\n\n    # Validate the number of each payment method type\n    if certificate_count > 1:\n        raise PolicyViolationException(\"More than one travel certificate is not allowed.\")\n    if credit_card_count > 1:\n        raise PolicyViolationException(\"More than one credit card is not allowed.\")\n    if gift_card_count > 3:\n        raise PolicyViolationException(\"More than three gift cards are not allowed.\")"
        },
        {
          "file_name": "airline/book_reservation/guard_checked_bag_allowance_by_membership_tier.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_checked_bag_allowance_by_membership_tier(history: ChatHistory, api: I_Airline, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], passengers: list[Passenger | dict], payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Policy to check: The checked bag allowance policy for booking a reservation varies by membership tier and cabin class: 1) Regular members have 0 free checked bags for basic economy, 1 for economy, and 2 for business. 2) Silver members have 1 free checked bag for basic economy, 2 for economy, and 3 for business. 3) Gold members have 2 free checked bags for basic economy, 3 for economy and business. An extra baggage fee of $50 applies for additional luggage.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'`.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n    \"\"\"\n    pass #FIXME"
        }
      ],
      "test_files": [
        null,
        {
          "file_name": "tests/book_reservation/test_guard_flight_status_restrictions.py",
          "content": "from unittest.mock import MagicMock, patch\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.book_reservation.guard_flight_status_restrictions import guard_flight_status_restrictions\nfrom airline.i_airline import *\nfrom airline.airline_types import *\nfrom datetime import datetime, timedelta\n\nclass TestGuardFlightStatusRestrictions:\n\n    def test_compliance_booking_available_flight(self):\n        \"\"\"\n        Policy: \"Flights chosen for booking using ToolX must have the status 'available' to ensure that they have not taken off.\"\n        Example: \"A user requests to book a flight from SFO to LAX on June 20th. The agent checks the flight information and confirms that the flight status is 'available' before proceeding with the booking using the BookReservation tool.\"\n        \"\"\"\n        \n        # mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # mock other tools function return values \n        api = MagicMock(spec=I_Airline)\n        api.get_flight_status.side_effect = lambda flight_number, date: 'available' if flight_number == \"HAT001\" and date == \"2024-06-20\" else None\n\n        flight_info = FlightInfo(flight_number=\"HAT001\", date=\"2024-06-20\")\n        passenger = Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")\n        payment = Payment(payment_id=\"pay123\", amount=200)\n\n        # invoke function under test\n        guard_flight_status_restrictions(\n            history=history,\n            api=api,\n            user_id=\"user123\",\n            origin=\"SFO\",\n            destination=\"LAX\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=[flight_info],\n            passengers=[passenger],\n            payment_methods=[payment],\n            total_baggages=1,\n            nonfree_baggages=0,\n            insurance=\"no\"\n        )\n\n    def test_violation_booking_delayed_flight(self):\n        \"\"\"\n        Policy: \"Flights with status 'delayed', 'on time', or 'flying' cannot be booked.\"\n        Example: \"A user attempts to book a flight to New York on May 16th using the BookReservation tool. However, the flight status indicates 'delayed'.\"\n        \"\"\"\n        \n        # mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # mock other tools function return values \n        api = MagicMock(spec=I_Airline)\n        api.get_flight_status.side_effect = lambda flight_number, date: 'delayed' if flight_number == \"HAT002\" and date == \"2024-05-16\" else None\n\n        flight_info = FlightInfo(flight_number=\"HAT002\", date=\"2024-05-16\")\n        passenger = Passenger(first_name=\"Jane\", last_name=\"Doe\", dob=\"1992-02-02\")\n        payment = Payment(payment_id=\"pay456\", amount=300)\n\n        # invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_flight_status_restrictions(\n                history=history,\n                api=api,\n                user_id=\"user456\",\n                origin=\"ATL\",\n                destination=\"NYC\",\n                flight_type=\"round_trip\",\n                cabin=\"business\",\n                flights=[flight_info],\n                passengers=[passenger],\n                payment_methods=[payment],\n                total_baggages=2,\n                nonfree_baggages=1,\n                insurance=\"yes\"\n            )\n\n    def test_violation_booking_flying_flight(self):\n        \"\"\"\n        Policy: \"Flights with status 'delayed', 'on time', or 'flying' cannot be booked.\"\n        Example: \"An agent tries to book a reservation for a user on flight HAT007 from ATL to MIA. The API checks reveal that the flight's status is currently 'flying'.\"\n        \"\"\"\n        \n        # mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # mock other tools function return values \n        api = MagicMock(spec=I_Airline)\n        api.get_flight_status.side_effect = lambda flight_number, date: 'flying' if flight_number == \"HAT007\" and date == \"2024-05-17\" else None\n\n        flight_info = FlightInfo(flight_number=\"HAT007\", date=\"2024-05-17\")\n        passenger = Passenger(first_name=\"Alice\", last_name=\"Smith\", dob=\"1985-03-03\")\n        payment = Payment(payment_id=\"pay789\", amount=400)\n\n        # invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_flight_status_restrictions(\n                history=history,\n                api=api,\n                user_id=\"user789\",\n                origin=\"ATL\",\n                destination=\"MIA\",\n                flight_type=\"one_way\",\n                cabin=\"economy\",\n                flights=[flight_info],\n                passengers=[passenger],\n                payment_methods=[payment],\n                total_baggages=3,\n                nonfree_baggages=2,\n                insurance=\"no\"\n            )\n\n    def test_violation_booking_on_time_flight(self):\n        \"\"\"\n        Policy: \"Flights with status 'delayed', 'on time', or 'flying' cannot be booked.\"\n        Example: \"A reservation request is made for a flight with the status 'on time'.\"\n        \"\"\"\n        \n        # mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # mock other tools function return values \n        api = MagicMock(spec=I_Airline)\n        api.get_flight_status.side_effect = lambda flight_number, date: 'on time' if flight_number == \"HAT008\" and date == \"2024-05-18\" else None\n\n        flight_info = FlightInfo(flight_number=\"HAT008\", date=\"2024-05-18\")\n        passenger = Passenger(first_name=\"Bob\", last_name=\"Brown\", dob=\"1975-04-04\")\n        payment = Payment(payment_id=\"pay012\", amount=500)\n\n        # invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_flight_status_restrictions(\n                history=history,\n                api=api,\n                user_id=\"user012\",\n                origin=\"LAX\",\n                destination=\"DFW\",\n                flight_type=\"round_trip\",\n                cabin=\"basic_economy\",\n                flights=[flight_info],\n                passengers=[passenger],\n                payment_methods=[payment],\n                total_baggages=4,\n                nonfree_baggages=3,\n                insurance=\"yes\"\n            )\n\n    def test_violation_booking_cancelled_flight(self):\n        \"\"\"\n        Policy: \"Flights with status 'delayed', 'on time', or 'flying' cannot be booked.\"\n        Example: \"A reservation is attempted for a flight where the status is 'cancelled'. Despite knowing that only flights with 'available' status can be booked, the agent proceeds, resulting in a policy breach.\"\n        \"\"\"\n        \n        # mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # mock other tools function return values \n        api = MagicMock(spec=I_Airline)\n        api.get_flight_status.side_effect = lambda flight_number, date: 'cancelled' if flight_number == \"HAT009\" and date == \"2024-05-19\" else None\n\n        flight_info = FlightInfo(flight_number=\"HAT009\", date=\"2024-05-19\")\n        passenger = Passenger(first_name=\"Charlie\", last_name=\"Davis\", dob=\"1965-05-05\")\n        payment = Payment(payment_id=\"pay345\", amount=600)\n\n        # invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_flight_status_restrictions(\n                history=history,\n                api=api,\n                user_id=\"user345\",\n                origin=\"SFO\",\n                destination=\"JFK\",\n                flight_type=\"one_way\",\n                cabin=\"business\",\n                flights=[flight_info],\n                passengers=[passenger],\n                payment_methods=[payment],\n                total_baggages=5,\n                nonfree_baggages=4,\n                insurance=\"no\"\n            )\n\n    def test_violation_booking_mixed_status_flights(self):\n        \"\"\"\n        Policy: \"Flights with status 'delayed', 'on time', or 'flying' cannot be booked.\"\n        Example: \"A user attempts to make a reservation with two flights. The first one's status is 'delayed', and the second one is 'available'.\"\n        \"\"\"\n        \n        # mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # mock other tools function return values \n        api = MagicMock(spec=I_Airline)\n        api.get_flight_status.side_effect = lambda flight_number, date: 'delayed' if flight_number == \"HAT010\" and date == \"2024-05-20\" else 'available' if flight_number == \"HAT011\" and date == \"2024-05-21\" else None\n\n        flight_info1 = FlightInfo(flight_number=\"HAT010\", date=\"2024-05-20\")\n        flight_info2 = FlightInfo(flight_number=\"HAT011\", date=\"2024-05-21\")\n        passenger = Passenger(first_name=\"Dana\", last_name=\"Evans\", dob=\"1955-06-06\")\n        payment = Payment(payment_id=\"pay678\", amount=700)\n\n        # invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_flight_status_restrictions(\n                history=history,\n                api=api,\n                user_id=\"user678\",\n                origin=\"ORD\",\n                destination=\"MIA\",\n                flight_type=\"round_trip\",\n                cabin=\"economy\",\n                flights=[flight_info1, flight_info2],\n                passengers=[passenger],\n                payment_methods=[payment],\n                total_baggages=6,\n                nonfree_baggages=5,\n                insurance=\"yes\"\n            )\n\n    def test_violation_booking_mixed_status_flights_reverse(self):\n        \"\"\"\n        Policy: \"Flights with status 'delayed', 'on time', or 'flying' cannot be booked.\"\n        Example: \"A user attempts to make a reservation with two flights. The first one's status is 'available', and the second one is 'delayed'.\"\n        \"\"\"\n        \n        # mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # mock other tools function return values \n        api = MagicMock(spec=I_Airline)\n        api.get_flight_status.side_effect = lambda flight_number, date: 'available' if flight_number == \"HAT012\" and date == \"2024-05-22\" else 'delayed' if flight_number == \"HAT013\" and date == \"2024-05-23\" else None\n\n        flight_info1 = FlightInfo(flight_number=\"HAT012\", date=\"2024-05-22\")\n        flight_info2 = FlightInfo(flight_number=\"HAT013\", date=\"2024-05-23\")\n        passenger = Passenger(first_name=\"Eve\", last_name=\"Foster\", dob=\"1945-07-07\")\n        payment = Payment(payment_id=\"pay901\", amount=800)\n\n        # invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_flight_status_restrictions(\n                history=history,\n                api=api,\n                user_id=\"user901\",\n                origin=\"SEA\",\n                destination=\"BOS\",\n                flight_type=\"round_trip\",\n                cabin=\"business\",\n                flights=[flight_info1, flight_info2],\n                passengers=[passenger],\n                payment_methods=[payment],\n                total_baggages=7,\n                nonfree_baggages=6,\n                insurance=\"no\"\n            )\n"
        },
        null,
        null,
        null,
        null
      ]
    },
    "cancel_reservation": {
      "tool": {
        "tool_name": "cancel_reservation",
        "policy_items": [
          {
            "name": "Cancellation Policy for All Flights",
            "description": "To use the 'cancel_reservation' tool, confirm the following with the user: 1) The cancellation is within 24 hours of booking, 2) The airline cancelled the flight, 3) For economy class, cancellation is only allowed if travel insurance was purchased and qualifies, 4) Business class flights can be cancelled anytime. These conditions must be validated prior to invoking the tool.",
            "references": [
              "All reservations can be cancelled within 24 hours of booking, or if the airline cancelled the flight. Otherwise, basic economy or economy flights can be cancelled only if travel insurance is bought and the condition is met, and business flights can always be cancelled. The rules are strict regardless of the membership status.",
              "The API does not check these for the agent, so the agent must make sure the rules apply before calling the API!"
            ],
            "compliance_examples": [
              "An agent checks and confirms the reservation was made within 24 hours before invoking CancelReservation.",
              "For a basic economy reservation done 36 hours ago, and the user has purchased travel insurance for flight canceling.",
              "An agent verifies that the airline has cancelled the flight before proceeding with the CancelReservation call.",
              "A user requests the cancellation of an economy class reservation booked 18 hours ago.",
              "A user with a business class reservation requests cancellation for a reservation done 40 hours ago."
            ],
            "violation_examples": [
              "A user contacts support to cancel a reservation for an economy class ticket without having purchased travel insurance, and the booking was made more than 24 hours ago.",
              "A basic user requests a reservation cancellation 48 hours after purchase, without the airline canceling any flights and the reservation has no insurance."
            ]
          },
          {
            "name": "Cancellation of Entire Trips Only",
            "description": "Before using the CancelReservation tool, the agent should confirm that the entire trip is unused. If any flight segment has already been flown, the reservation cannot be canceled by the agent and should be escalated to a human agent.",
            "references": [
              "The agent can only cancel the whole trip that is not flown. If any of the segments are already used, the agent cannot help and transfer is needed."
            ],
            "compliance_examples": [
              "An agent receives a user request for cancellation and checks each flight segment to ensure none have been flown or taken off. After verifying that all segments are 'scheduled', the agent proceeds with the CancelReservation tool in compliance with the policy.",
              "Before calling the CancelReservation tool, the agent reviews the reservation details and confirms that all flight segments have a status of 'available' and none have been departed or used. The cancellation is then processed, adhering to the policy.",
              "The agent is asked to cancel a trip and confirms each segment of the reservation is still 'on time' with a future departure. After verifying no segments have flown, the agent processes the full cancellation successfully following policy guidelines.",
              "Upon a cancellation request, the agent checks reservation details and finds all flight segments under 'available' and none used. After this thorough validation against the policy requirements, the agent calls the CancelReservation tool.",
              "Upon receiving a cancellation request, the agent carefully reviews the reservation details and confirms that all flight segments have a status of 'delayed' but have not departed. Ensuring compliance, the agent proceeds with the cancellation.",
              "The agent is asked to cancel a reservation and verifies all flight segments are in 'scheduled' status. After ensuring that the segments are not flown and there's no discrepancy in status, the agent follows the policy and proceeds with the cancellation.",
              "A user requests cancellation for their trip, and the agent conducts a thorough check to confirm all segments are 'flying' but have not completed any leg. Ensuring no segments are considered 'used', the agent processes the request as per the policy's compliance.",
              "Before processing a cancellation, the agent confirms that the reservation details show all segments as 'on time', yet still at the gate. This early confirmation allows safe adherence to the policy, and the agent cancels the reservation.",
              "An agent receives a cancellation request and meticulously checks that all flight segments within the reservation have the status 'scheduled'. After confirming that no segments have been flown, the agent calls CancelReservation in line with the policy.",
              "Upon receiving a cancellation request, the agent validates that none of the flights have the status 'departed'. The agent confirms each segment reflects a 'scheduled' status before proceeding, thus adhering to the policy.",
              "Before initiating the cancellation, the agent calculates the latest status of all segments. All the flights show as 'scheduled', so with this confirmed safe status, the agent executes CancelReservation correctly.",
              "The agent evaluates the reservation and checks the flight records: all segments are confirmed as 'delayed', yet none have reached 'departed'. Confirming compliance, the agent proceeds with the complete cancellation.",
              "Before proceeding with the CancelReservation, the agent validates the flight details, confirming that all segments are currently marked 'scheduled' with no ongoing or completed statuses. This thorough check ensures adherence to the policy before executing the cancellation.",
              "An agent is tasked with a cancellation and conducts a comprehensive check of each flight segment status. Upon confirming all are marked 'available' and unflown, the agent complies with policy requirements by using the CancelReservation tool cleanly.",
              "The agent, upon receiving a request for cancellation, meticulously reviews the reservation, confirming that no part of the trip has been flown or is currently underway. This diligence complies with the policy, allowing safe execution of the CancelReservation tool.",
              "Upon receiving a cancellation request, the agent accesses each flight detail within the reservation, identifying all segments as 'scheduled' and unflown before aptly utilizing the CancelReservation tool according to policy.",
              "During a busy shift, the agent maintains rigor by validating every flight segment of a reservation as 'delayed but not departed' and adheres to the policy by confirming this before processing the cancellation."
            ],
            "violation_examples": [
              "An agent tries to call the CancelReservation tool without verifying the status of all flight segments in the reservation.",
              "The agent receives a request to cancel a trip, and while one of the segments shows a 'flying' status, the agent proceeds with CancelReservation.",
              "An agent cancels a reservation marking all segments as 'scheduled' without confirming their status. Post-cancellation, it is discovered that one segment was marked 'delayed' but has already departed, violating the policy that mandates confirming every segment before cancellation.",
              "The agent proceeds to call CancelReservation after only checking a subset of flight segments, assuming the others are unused. However, it is later revealed that this assumption was incorrect, as some segments were in 'departed' status, which violates the policy requiring complete verification.",
              "An agent falsely assumes that since the trip is set to occur in the future, none of the flights have been flown, and calls the CancelReservation tool. Upon review, one segment is found to have been flown, breaking the policy which requires a check prior to cancellation.",
              "An agent initiates the CancelReservation tool after only a brief glance at the reservation details, assuming that a delay means the segment hasn't departed when in actuality, the flight has taken off. This action violates the policy since all segments status must be verified accurately before cancellation.",
              "A user inquires about canceling a trip with multiple flight legs. The agent overlooks checking the status of each individual segment and proceeds with the cancellation based on user assurance, later finding one segment was flown, not complying with the policy guidelines.",
              "The agent immediately processes a cancellation request for a business class reservation without confirming if all flights are entirely unused. One flight being marked as 'on time' was actually close to takeoff, thus not adhering to the necessary policy to verify flight status before using the tool.",
              "The agent receives a user request to cancel a trip and skips over verifying the status of connecting flights that involve multiple airlines. It is later discovered that one of the connecting segments had already taken off, violating the policy of confirming each segment\u2019s status before cancellation.",
              "An agent attempts to process a cancellation request for a very complex itinerary involving multiple layovers and accidentally misses a segment that had changed status to 'departed'. This oversight breaches the policy's requirement that no flown segments be present before using the CancelReservation tool.",
              "Facing a high volume of requests, an agent decides to batch process cancellations, inadvertently including a reservation where one of the segments was 'flying', thus violating the requirement to transfer such cases to a human agent."
            ]
          }
        ]
      },
      "guard_fn_name": "guard_cancel_reservation",
      "guard_file": {
        "file_name": "airline/cancel_reservation/guard_cancel_reservation.py",
        "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\nfrom airline.cancel_reservation.guard_cancellation_policy_for_all_flights import guard_cancellation_policy_for_all_flights\nfrom airline.cancel_reservation.guard_cancellation_of_entire_trips_only import guard_cancellation_of_entire_trips_only\n\n\ndef guard_cancel_reservation(history: ChatHistory, api: I_Airline, reservation_id: str):\n    \"\"\"\n    Checks that a tool call complies to the policies.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n         \n    \"\"\"\n    \n    guard_cancellation_policy_for_all_flights(history, api, reservation_id)\n    guard_cancellation_of_entire_trips_only(history, api, reservation_id)\n"
      },
      "item_guard_files": [
        {
          "file_name": "airline/cancel_reservation/guard_cancellation_policy_for_all_flights.py",
          "content": "from typing import *\nfrom datetime import datetime, timedelta\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\n\ndef guard_cancellation_policy_for_all_flights(history: ChatHistory, api: I_Airline, reservation_id: str):\n    \"\"\"\n    Policy to check: To use the 'cancel_reservation' tool, confirm the following with the user: \n    1) The cancellation is within 24 hours of booking, \n    2) The airline cancelled the flight, \n    3) For economy class, cancellation is only allowed if travel insurance was purchased and qualifies, \n    4) Business class flights can be cancelled anytime. \n    These conditions must be validated prior to invoking the tool.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n    \"\"\"\n    # Fetch reservation details\n    reservation = api.get_reservation_details(reservation_id)\n    \n    # Check if the cancellation is within 24 hours of booking\n    booking_time = datetime.strptime(reservation.created_at, \"%Y-%m-%dT%H:%M:%S\")\n    if datetime.now() - booking_time <= timedelta(hours=24):\n        return\n\n    # Check if the airline cancelled the flight\n    for flight in reservation.flights:\n        flight_status = api.get_flight_status(flight.flight_number, flight.date)\n        if flight_status == 'cancelled':\n            return\n\n    # Check for economy class with travel insurance\n    if reservation.cabin in ['economy', 'basic_economy']:\n        if reservation.insurance == 'yes':\n            return\n        else:\n            raise PolicyViolationException(\"Economy class cancellation requires travel insurance.\")\n\n    # Check for business class\n    if reservation.cabin == 'business':\n        return\n\n    # If none of the conditions are met, raise an exception\n    raise PolicyViolationException(\"Cancellation policy conditions not met.\")"
        },
        {
          "file_name": "airline/cancel_reservation/guard_cancellation_of_entire_trips_only.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\n\ndef guard_cancellation_of_entire_trips_only(history: ChatHistory, api: I_Airline, reservation_id: str):\n    \"\"\"\n    Policy to check: Before using the CancelReservation tool, the agent should confirm that the entire trip is unused. If any flight segment has already been flown, the reservation cannot be canceled by the agent and should be escalated to a human agent.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n    \"\"\"\n    try:\n        reservation = api.get_reservation_details(reservation_id)\n        for flight in reservation.flights:\n            flight_status = api.get_flight_status(flight.flight_number, flight.date)\n            if flight_status in ['flying', 'landed', 'departed']:\n                raise PolicyViolationException(\"Cannot cancel reservation as one or more flight segments have already been flown.\")\n    except ValueError as e:\n        raise PolicyViolationException(f\"Error retrieving reservation details: {str(e)}\")"
        }
      ],
      "test_files": [
        {
          "file_name": "tests/cancel_reservation/test_guard_cancellation_policy_for_all_flights.py",
          "content": "from unittest.mock import MagicMock, patch\nimport pytest\nfrom datetime import datetime, timedelta\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.cancel_reservation.guard_cancellation_policy_for_all_flights import guard_cancellation_policy_for_all_flights\nfrom airline.i_airline import I_Airline\nfrom airline.airline_types import Reservation\n\n# Compliance Test: An agent checks and confirms the reservation was made within 24 hours before invoking CancelReservation.\ndef test_cancellation_within_24_hours():\n    \"\"\"\n    Policy: \"The cancellation is within 24 hours of booking\"\n    Example: \"An agent checks and confirms the reservation was made within 24 hours before invoking CancelReservation.\"\n    \"\"\"\n    # Mock the history service\n    history = MagicMock()\n    history.ask_bool.return_value = True\n\n    # Mock the API\n    api = MagicMock(spec=I_Airline)\n    reservation = Reservation(\n        reservation_id=\"ZFA04Y\",\n        user_id=\"user123\",\n        origin=\"JFK\",\n        destination=\"LAX\",\n        flight_type=\"one_way\",\n        cabin=\"economy\",\n        flights=[],\n        passengers=[],\n        payment_history=[],\n        created_at=(datetime.now() - timedelta(hours=23)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n        total_baggages=0,\n        nonfree_baggages=0,\n        insurance=\"no\",\n        status=None\n    )\n    api.get_reservation_details.return_value = reservation\n\n    # Invoke function under test\n    try:\n        guard_cancellation_policy_for_all_flights(history, api, \"ZFA04Y\")\n    except PolicyViolationException:\n        pytest.fail(\"Cancellation within 24 hours should not raise PolicyViolationException.\")\n\n# Violation Test: A user contacts support to cancel a reservation for an economy class ticket without having purchased travel insurance, and the booking was made more than 24 hours ago.\ndef test_cancellation_without_insurance_past_24_hours():\n    \"\"\"\n    Policy: \"For economy class, cancellation is only allowed if travel insurance was purchased and qualifies\"\n    Example: \"A user contacts support to cancel a reservation for an economy class ticket without having purchased travel insurance, and the booking was made more than 24 hours ago.\"\n    \"\"\"\n    # Mock the history service\n    history = MagicMock()\n    history.ask_bool.return_value = False\n\n    # Mock the API\n    api = MagicMock(spec=I_Airline)\n    reservation = Reservation(\n        reservation_id=\"ZFA04Y\",\n        user_id=\"user123\",\n        origin=\"JFK\",\n        destination=\"LAX\",\n        flight_type=\"one_way\",\n        cabin=\"economy\",\n        flights=[],\n        passengers=[],\n        payment_history=[],\n        created_at=(datetime.now() - timedelta(hours=25)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n        total_baggages=0,\n        nonfree_baggages=0,\n        insurance=\"no\",\n        status=None\n    )\n    api.get_reservation_details.return_value = reservation\n\n    # Invoke function under test\n    with pytest.raises(PolicyViolationException):\n        guard_cancellation_policy_for_all_flights(history, api, \"ZFA04Y\")"
        },
        {
          "file_name": "tests/cancel_reservation/test_guard_cancellation_of_entire_trips_only.py",
          "content": "from unittest.mock import MagicMock, patch\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.cancel_reservation.guard_cancellation_of_entire_trips_only import guard_cancellation_of_entire_trips_only\nfrom airline.i_airline import *\nfrom datetime import datetime, timedelta\n\nclass TestGuardCancellationOfEntireTripsOnly:\n\n    def test_compliance_all_segments_scheduled(self):\n        \"\"\"\n        Policy: \"Before using the CancelReservation tool, the agent should confirm that the entire trip is unused.\"\n        Example: \"An agent receives a user request for cancellation and checks each flight segment to ensure none have been flown or taken off.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n        reservation = Reservation(reservation_id=\"ZFA04Y\", user_id=\"user123\", origin=\"SFO\", destination=\"JFK\", flight_type=\"round_trip\", cabin=\"economy\", flights=[\n            ReservationFlight(flight_number=\"HAT001\", date=\"2024-05-01\", price=300, origin=\"SFO\", destination=\"JFK\")\n        ], passengers=[], payment_history=[], created_at=\"2023-01-01T00:00:00\", total_baggages=0, nonfree_baggages=0, insurance=\"no\", status=None)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n        api.get_flight_status.side_effect = lambda flight_number, date: \"scheduled\" if flight_number == \"HAT001\" and date == \"2024-05-01\" else \"departed\"\n\n        # Invoke function under test\n        guard_cancellation_of_entire_trips_only(history, api, reservation_id=\"ZFA04Y\")\n\n    def test_violation_segment_flying(self):\n        \"\"\"\n        Policy: \"Before using the CancelReservation tool, the agent should confirm that the entire trip is unused.\"\n        Example: \"The agent receives a request to cancel a trip, and while one of the segments shows a 'flying' status, the agent proceeds with CancelReservation.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n        reservation = Reservation(reservation_id=\"ZFA04Y\", user_id=\"user123\", origin=\"SFO\", destination=\"JFK\", flight_type=\"round_trip\", cabin=\"economy\", flights=[\n            ReservationFlight(flight_number=\"HAT001\", date=\"2024-05-01\", price=300, origin=\"SFO\", destination=\"JFK\")\n        ], passengers=[], payment_history=[], created_at=\"2023-01-01T00:00:00\", total_baggages=0, nonfree_baggages=0, insurance=\"no\", status=None)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n        api.get_flight_status.side_effect = lambda flight_number, date: \"flying\" if flight_number == \"HAT001\" and date == \"2024-05-01\" else \"departed\"\n\n        # Invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_cancellation_of_entire_trips_only(history, api, reservation_id=\"ZFA04Y\")\n\n    def test_violation_segment_departed(self):\n        \"\"\"\n        Policy: \"Before using the CancelReservation tool, the agent should confirm that the entire trip is unused.\"\n        Example: \"An agent cancels a reservation marking all segments as 'scheduled' without confirming their status.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n        reservation = Reservation(reservation_id=\"ZFA04Y\", user_id=\"user123\", origin=\"SFO\", destination=\"JFK\", flight_type=\"round_trip\", cabin=\"economy\", flights=[\n            ReservationFlight(flight_number=\"HAT001\", date=\"2024-05-01\", price=300, origin=\"SFO\", destination=\"JFK\")\n        ], passengers=[], payment_history=[], created_at=\"2023-01-01T00:00:00\", total_baggages=0, nonfree_baggages=0, insurance=\"no\", status=None)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n        api.get_flight_status.side_effect = lambda flight_number, date: \"departed\" if flight_number == \"HAT001\" and date == \"2024-05-01\" else \"scheduled\"\n\n        # Invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_cancellation_of_entire_trips_only(history, api, reservation_id=\"ZFA04Y\")\n"
        }
      ]
    },
    "update_reservation_passengers": {
      "tool": {
        "tool_name": "update_reservation_passengers",
        "policy_items": [
          {
            "name": "Updating Passengers Information",
            "description": "Ensure all passengers including first name, last name, and date of birth.",
            "references": [
              "The agent needs to collect the first name, last name, and date of birth for each passenger."
            ],
            "compliance_examples": [
              "A user asks for replacing one passengers with another, providing all required details.",
              "A gold user flying business asks to replace himself with a different person, providing all his details."
            ],
            "violation_examples": [
              "An agent attempts updating passengers while missing the date of birth for each passenger.",
              "An agent attempts updating passengers information while missing a passenger's first name.",
              "An agent attempts updating passengers information while missing a passenger's last name."
            ]
          },
          {
            "name": "Changing the Number of Passengers is not Allowed",
            "description": "Users are restricted to only updating passenger details such as names or dates of birth within existing reservations. They are not allowed to alter the total number of passengers included in a booking. This limitation applies even when handed over to human agents.",
            "references": [
              "Change passengers: The user can modify passengers but cannot modify the number of passengers.",
              "This is something that even a human agent cannot assist with."
            ],
            "compliance_examples": [
              "A user requests to correct the spelling of a passenger's name on their reservation.",
              "A reservation initially includes three passengers. The agent modifies the date of birth of one passenger.",
              "The agent uses UpdateReservationPassengers to correct the last name of a passenger who realized their name was entered incorrectly during booking.",
              "An agent uses the UpdateReservationPassengers tool to update the last name of one of the existing passengers in a reservation."
            ],
            "violation_examples": [
              "A user attempts to update their reservation by adding an additional passenger.",
              "An agent calls the UpdateReservationPassengers tool, attempting to add details for a sixth passenger to a reservation that initially had five passengers.",
              "A gold user asks to add third passenger to their reservation and change the date of birth of one of the existing two.",
              "A user requests the agent to remove an existing passenger from their reservation."
            ]
          }
        ]
      },
      "guard_fn_name": "guard_update_reservation_passengers",
      "guard_file": {
        "file_name": "airline/update_reservation_passengers/guard_update_reservation_passengers.py",
        "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\nfrom airline.update_reservation_passengers.guard_updating_passengers_information import guard_updating_passengers_information\nfrom airline.update_reservation_passengers.guard_changing_the_number_of_passengers_is_not_allowed import guard_changing_the_number_of_passengers_is_not_allowed\n\n\ndef guard_update_reservation_passengers(history: ChatHistory, api: I_Airline, reservation_id: str, passengers: list[Passenger | dict]):\n    \"\"\"\n    Checks that a tool call complies to the policies.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        passengers: An array of objects containing details about each passenger.\n         \n    \"\"\"\n    \n    guard_updating_passengers_information(history, api, reservation_id, passengers)\n    guard_changing_the_number_of_passengers_is_not_allowed(history, api, reservation_id, passengers)\n"
      },
      "item_guard_files": [
        {
          "file_name": "airline/update_reservation_passengers/guard_updating_passengers_information.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_updating_passengers_information(history: ChatHistory, api: I_Airline, reservation_id: str, passengers: list[Passenger | dict]):\n    \"\"\"\n    Policy to check: Ensure all passengers including first name, last name, and date of birth.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        passengers: An array of objects containing details about each passenger.\n    \"\"\"\n    for passenger in passengers:\n        if isinstance(passenger, dict):\n            first_name = passenger.get('first_name')\n            last_name = passenger.get('last_name')\n            dob = passenger.get('dob')\n        else:\n            first_name = passenger.first_name\n            last_name = passenger.last_name\n            dob = passenger.dob\n\n        if not first_name:\n            raise PolicyViolationException(\"Missing first name for a passenger.\")\n        if not last_name:\n            raise PolicyViolationException(\"Missing last name for a passenger.\")\n        if not dob:\n            raise PolicyViolationException(\"Missing date of birth for a passenger.\")"
        },
        {
          "file_name": "airline/update_reservation_passengers/guard_changing_the_number_of_passengers_is_not_allowed.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_changing_the_number_of_passengers_is_not_allowed(history: ChatHistory, api: I_Airline, reservation_id: str, passengers: list[Passenger | dict]):\n    \"\"\"\n    Policy to check: Users are restricted to only updating passenger details such as names or dates of birth within existing reservations. They are not allowed to alter the total number of passengers included in a booking. This limitation applies even when handed over to human agents.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        passengers: An array of objects containing details about each passenger.\n    \"\"\"\n    # Retrieve the current reservation details\n    reservation = api.get_reservation_details(reservation_id)\n    \n    # Check if the number of passengers in the reservation matches the number of passengers provided\n    if len(reservation.passengers) != len(passengers):\n        raise PolicyViolationException(\"Users are not allowed to alter the total number of passengers included in a booking.\")"
        }
      ],
      "test_files": [
        {
          "file_name": "tests/update_reservation_passengers/test_guard_updating_passengers_information.py",
          "content": "from unittest.mock import MagicMock, patch\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.update_reservation_passengers.guard_updating_passengers_information import guard_updating_passengers_information\nfrom airline.i_airline import *\nfrom airline.airline_types import *\nfrom datetime import datetime, timedelta\n\nclass TestGuardUpdatingPassengersInformation:\n\n    def test_compliance_replace_passenger_with_all_details(self):\n        \"\"\"\n        Policy: \"Ensure all passengers including first name, last name, and date of birth.\"\n        Example: \"A user asks for replacing one passengers with another, providing all required details.\"\n        \"\"\"\n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user_123\",\n            origin=\"JFK\",\n            destination=\"LAX\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=[],\n            passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=1)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\",\n            status=None\n        )\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n\n        # Invoke function under test\n        guard_updating_passengers_information(\n            history=history,\n            api=api,\n            reservation_id=\"ZFA04Y\",\n            passengers=[{\"first_name\": \"Jane\", \"last_name\": \"Smith\", \"dob\": \"1985-05-15\"}]\n        )\n\n    def test_violation_missing_date_of_birth(self):\n        \"\"\"\n        Policy: \"Ensure all passengers including first name, last name, and date of birth.\"\n        Example: \"An agent attempts updating passengers while missing the date of birth for each passenger.\"\n        \"\"\"\n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user_123\",\n            origin=\"JFK\",\n            destination=\"LAX\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=[],\n            passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=1)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\",\n            status=None\n        )\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n\n        # Invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_updating_passengers_information(\n                history=history,\n                api=api,\n                reservation_id=\"ZFA04Y\",\n                passengers=[{\"first_name\": \"Jane\", \"last_name\": \"Smith\"}]\n            )\n\n    def test_violation_missing_first_name(self):\n        \"\"\"\n        Policy: \"Ensure all passengers including first name, last name, and date of birth.\"\n        Example: \"An agent attempts updating passengers information while missing a passenger's first name.\"\n        \"\"\"\n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user_123\",\n            origin=\"JFK\",\n            destination=\"LAX\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=[],\n            passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=1)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\",\n            status=None\n        )\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n\n        # Invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_updating_passengers_information(\n                history=history,\n                api=api,\n                reservation_id=\"ZFA04Y\",\n                passengers=[{\"last_name\": \"Smith\", \"dob\": \"1985-05-15\"}]\n            )\n\n    def test_violation_missing_last_name(self):\n        \"\"\"\n        Policy: \"Ensure all passengers including first name, last name, and date of birth.\"\n        Example: \"An agent attempts updating passengers information while missing a passenger's last name.\"\n        \"\"\"\n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user_123\",\n            origin=\"JFK\",\n            destination=\"LAX\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=[],\n            passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=1)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\",\n            status=None\n        )\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n\n        # Invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_updating_passengers_information(\n                history=history,\n                api=api,\n                reservation_id=\"ZFA04Y\",\n                passengers=[{\"first_name\": \"Jane\", \"dob\": \"1985-05-15\"}]\n            )\n"
        },
        {
          "file_name": "tests/update_reservation_passengers/test_guard_changing_the_number_of_passengers_is_not_allowed.py",
          "content": "from unittest.mock import MagicMock, patch\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.update_reservation_passengers.guard_changing_the_number_of_passengers_is_not_allowed import guard_changing_the_number_of_passengers_is_not_allowed\nfrom airline.i_airline import *\nfrom airline.airline_types import *\nfrom datetime import datetime, timedelta\n\nclass TestGuardChangingNumberOfPassengers:\n\n    def test_correct_spelling_of_passenger_name(self):\n        \"\"\"\n        Policy: \"Users are restricted to only updating passenger details such as names or dates of birth within existing reservations.\"\n        Example: \"A user requests to correct the spelling of a passenger's name on their reservation.\"\n        \"\"\"\n        \n        # mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # mock other tools function return values \n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user123\",\n            origin=\"JFK\",\n            destination=\"LAX\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=[],\n            passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")],\n            payment_history=[],\n            created_at=\"2023-01-01T00:00:00\",\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\",\n            status=None\n        )\n\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n        \n        # invoke function under test.\n        guard_changing_the_number_of_passengers_is_not_allowed(history, api, reservation_id=\"ZFA04Y\", passengers=[Passenger(first_name=\"Jon\", last_name=\"Doe\", dob=\"1990-01-01\")])\n\n    def test_additional_passenger_attempt(self):\n        \"\"\"\n        Policy: \"Users are not allowed to alter the total number of passengers included in a booking.\"\n        Example: \"A user attempts to update their reservation by adding an additional passenger.\"\n        \"\"\"\n        \n        # mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # mock other tools function return values \n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user123\",\n            origin=\"JFK\",\n            destination=\"LAX\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=[],\n            passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")],\n            payment_history=[],\n            created_at=\"2023-01-01T00:00:00\",\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\",\n            status=None\n        )\n\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n        \n        # invoke function under test.\n        with pytest.raises(PolicyViolationException):\n            guard_changing_the_number_of_passengers_is_not_allowed(history, api, reservation_id=\"ZFA04Y\", passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\"), Passenger(first_name=\"Jane\", last_name=\"Doe\", dob=\"1992-02-02\")])\n\n    def test_remove_existing_passenger(self):\n        \"\"\"\n        Policy: \"Users are not allowed to alter the total number of passengers included in a booking.\"\n        Example: \"A user requests the agent to remove an existing passenger from their reservation.\"\n        \"\"\"\n        \n        # mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # mock other tools function return values \n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user123\",\n            origin=\"JFK\",\n            destination=\"LAX\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=[],\n            passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\"), Passenger(first_name=\"Jane\", last_name=\"Doe\", dob=\"1992-02-02\")],\n            payment_history=[],\n            created_at=\"2023-01-01T00:00:00\",\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\",\n            status=None\n        )\n\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n        \n        # invoke function under test.\n        with pytest.raises(PolicyViolationException):\n            guard_changing_the_number_of_passengers_is_not_allowed(history, api, reservation_id=\"ZFA04Y\", passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")])\n"
        }
      ]
    },
    "update_reservation_baggages": {
      "tool": {
        "tool_name": "update_reservation_baggages",
        "policy_items": [
          {
            "name": "Only Adding Checked Bags is Allowed",
            "description": "You can update the baggage information of an existing reservation, allowing users to add additional checked bags. Removing checked bags from the reservation is not permitted. Ensure the payment method for any additional non-free baggage is provided at invocation.",
            "references": [
              "Change baggage and insurance: The user can add but not remove checked bags."
            ],
            "compliance_examples": [
              "A reservation for ID 'AX37VB' initially has 2 checked bags, the airline agent calls UpdateReservationBaggages to increase the total checked bags to 3.",
              "For reservation ID 'ZL58NM', the agent prepares to add two more checked bag, increase 'total_baggages' from 0 to 2."
            ],
            "violation_examples": [
              "Updating a reservation to reduce the total number of baggage items from 3 to 2 for reservation ID 'ZFA04Y'.",
              "updating a reservation 'total_baggages' to 1, previously it was set to 2 for reservation ID '5RN9XZ'.",
              "Despite the user requesting to remove a checked bag, the agent submits a request using UpdateReservationBaggages to change 'total_baggages' from 4 to 3.",
              "An agent mistakenly uses UpdateReservationBaggages and tries to adjust the total baggage count from 2 to 0 for reservation ID 'XJ92KL'."
            ]
          },
          {
            "name": "Payment Methods Are Pre-Authorized",
            "description": "Before invoking UpdateReservationBaggages, ensure all payment methods such as travel certificates, credit cards, and gift cards appear in the user's profile. Use a maximum of one travel certificate, one credit card, and up to three gift cards per reservation as per company policy.",
            "references": [
              "Payment: each reservation can use at most one travel certificate, at most one credit card, and at most three gift cards. The remaining amount of a travel certificate is not refundable.",
              "All payment methods must already be in user profile for safety reasons."
            ],
            "compliance_examples": [
              "Updating a reservation providing a credit card that is listed in the user's profile.",
              "The agent updates the baggage information using one pre-authorized travel certificate from the user's profile and an accompanying gift card.",
              "The agent uses two gift cards to cover the baggage update charges, ensuring both cards are pre-authorized and listed in the user's profile.",
              "The baggage information update is performed using one travel certificate and one credit card, both verified and listed in the user's profile."
            ],
            "violation_examples": [
              "Calling UpdateReservationBaggages with a payment ID for a credit card that has not been listed in the user's profile.",
              "A request to UpdateReservationBaggages uses a gift card that is not stored in the user's profile.",
              "Updating a reservation without providing a payment id",
              "The agent uses two credit cards in a single reservation to pay for additional baggage charges.",
              "The agent tries to apply two separate travel certificates towards updating baggage fees for a single reservation.",
              "An agent submits an UpdateReservationBaggages request using four gift cards for payment.",
              "An agent attempts to call UpdateReservationBaggages without verifying whether the payment method IDs are present in the user's profile.",
              "In an attempt to update baggage details, an agent mistakenly uses a credit card and two travel certificates."
            ]
          },
          {
            "name": "Charge for Extra Baggage Items",
            "description": "To use the UpdateReservationBaggages tool effectively, verify the user's membership level (regular, silver, or gold) and cabin class (basic economy, economy, business). This will determine the number of free checked bags allowed. Charge $50 for each additional baggage item beyond the free allowance according to the user's membership and cabin class entitlements.",
            "references": [
              "Checked bag allowance: If the booking user is a regular member, 0 free checked bag for each basic economy passenger, 1 free checked bag for each economy passenger, and 2 free checked bags for each business passenger. If the booking user is a silver member, 1 free checked bag for each basic economy passenger, 2 free checked bag for each economy passenger, and 3 free checked bags for each business passenger. If the booking user is a gold member, 2 free checked bag for each basic economy passenger, 3 free checked bag for each economy passenger, and 3 free checked bags for each business passenger.",
              "Each extra baggage is 50 dollars."
            ],
            "compliance_examples": [
              "A silver member with a basic economy ticket asks to update their reservation to include three checked baggages. The first checked bag is free, and the agent correctly applies a $100 charge for the two extra nonfree baggages.",
              "The agent updates the baggage information for a gold member flying business class by allowing the user to include four checked bags. The agent charges $50 for the extra baggage beyond the three free ones allowed by this membership and cabin class combination.",
              "A regular member in basic economy requests to add three extra baggages to their reservation for three passengers. The system correctly charges $150 for these nonfree baggages.",
              "The agent updates a reservation for a gold member in business class, allowing a total of six bags: three free as per policy, and other three for the charge of $150 as additional charge for the additional nonfree bags.",
              "A regular member asks for additional bag for his single bag in business class reservation, making it two in total, without any additional charges."
            ],
            "violation_examples": [
              "A user with a regular membership books a reservation in basic economy and requests to update the baggage to include one checked baggage item without paying any fees.",
              "The airline agent updates the baggage information for a silver member traveling in economy class to include four more baggage items than the free allowance, without using any payment method for the extra charges.",
              "An agent attempts to update the baggage for a gold member flying business class to have five total baggage items but mistakenly charges only for one excess baggage, despite only three being free based on their membership and cabin class.",
              "The agent attempts to update the baggage for a regular member flying business class to include three total bags and mistakenly charges for all three.",
              "A regular member asks for adding an extra bag for economy class, and the agent charges him with $25 only, while it should be $50.",
              "A regular member asks for adding an extra bag for economy class, and the agent charges him with $75, while it should be 50$.",
              "A regular member asks to add four total extra bags for three economy class passengers."
            ]
          }
        ]
      },
      "guard_fn_name": "guard_update_reservation_baggages",
      "guard_file": {
        "file_name": "airline/update_reservation_baggages/guard_update_reservation_baggages.py",
        "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\nfrom airline.update_reservation_baggages.guard_only_adding_checked_bags_is_allowed import guard_only_adding_checked_bags_is_allowed\nfrom airline.update_reservation_baggages.guard_payment_methods_are_pre_authorized import guard_payment_methods_are_pre_authorized\nfrom airline.update_reservation_baggages.guard_charge_for_extra_baggage_items import guard_charge_for_extra_baggage_items\n\n\ndef guard_update_reservation_baggages(history: ChatHistory, api: I_Airline, reservation_id: str, total_baggages: int, nonfree_baggages: int, payment_id: str):\n    \"\"\"\n    Checks that a tool call complies to the policies.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'\n        total_baggages: The updated total number of baggage items included in the reservation.\n        nonfree_baggages: The updated number of non-free baggage items included in the reservation.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n         \n    \"\"\"\n    \n    guard_only_adding_checked_bags_is_allowed(history, api, reservation_id, total_baggages, nonfree_baggages, payment_id)\n    guard_payment_methods_are_pre_authorized(history, api, reservation_id, total_baggages, nonfree_baggages, payment_id)\n    guard_charge_for_extra_baggage_items(history, api, reservation_id, total_baggages, nonfree_baggages, payment_id)\n"
      },
      "item_guard_files": [
        {
          "file_name": "airline/update_reservation_baggages/guard_only_adding_checked_bags_is_allowed.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_only_adding_checked_bags_is_allowed(history: ChatHistory, api: I_Airline, reservation_id: str, total_baggages: int, nonfree_baggages: int, payment_id: str):\n    \"\"\"\n    Policy to check: You can update the baggage information of an existing reservation, allowing users to add additional checked bags. Removing checked bags from the reservation is not permitted. Ensure the payment method for any additional non-free baggage is provided at invocation.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'\n        total_baggages: The updated total number of baggage items included in the reservation.\n        nonfree_baggages: The updated number of non-free baggage items included in the reservation.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n    \"\"\"\n    # Retrieve current reservation details\n    reservation = api.get_reservation_details(reservation_id)\n    current_total_baggages = reservation.total_baggages\n\n    # Check if the total baggage count is being reduced\n    if total_baggages < current_total_baggages:\n        raise PolicyViolationException(\"Removing checked bags from the reservation is not permitted.\")\n\n    # Ensure payment method is provided for non-free baggage\n    if nonfree_baggages > 0 and not payment_id:\n        raise PolicyViolationException(\"Payment method must be provided for non-free baggage.\")"
        },
        {
          "file_name": "airline/update_reservation_baggages/guard_payment_methods_are_pre_authorized.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_payment_methods_are_pre_authorized(history: ChatHistory, api: I_Airline, reservation_id: str, total_baggages: int, nonfree_baggages: int, payment_id: str):\n    \"\"\"\n    Policy to check: Before invoking UpdateReservationBaggages, ensure all payment methods such as travel certificates, credit cards, and gift cards appear in the user's profile. Use a maximum of one travel certificate, one credit card, and up to three gift cards per reservation as per company policy.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'\n        total_baggages: The updated total number of baggage items included in the reservation.\n        nonfree_baggages: The updated number of non-free baggage items included in the reservation.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/update_reservation_baggages/guard_charge_for_extra_baggage_items.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_charge_for_extra_baggage_items(history: ChatHistory, api: I_Airline, reservation_id: str, total_baggages: int, nonfree_baggages: int, payment_id: str):\n    \"\"\"\n    Policy to check: To use the UpdateReservationBaggages tool effectively, verify the user's membership level (regular, silver, or gold) and cabin class (basic economy, economy, business). This will determine the number of free checked bags allowed. Charge $50 for each additional baggage item beyond the free allowance according to the user's membership and cabin class entitlements.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'\n        total_baggages: The updated total number of baggage items included in the reservation.\n        nonfree_baggages: The updated number of non-free baggage items included in the reservation.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n    \"\"\"\n    pass #FIXME"
        }
      ],
      "test_files": [
        {
          "file_name": "tests/update_reservation_baggages/test_guard_only_adding_checked_bags_is_allowed.py",
          "content": "from unittest.mock import MagicMock, patch\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.update_reservation_baggages.guard_only_adding_checked_bags_is_allowed import guard_only_adding_checked_bags_is_allowed\nfrom airline.i_airline import *\nfrom datetime import datetime, timedelta\n\nclass TestGuardOnlyAddingCheckedBagsIsAllowed:\n\n    def test_increase_checked_bags(self):\n        \"\"\"\n        Policy: \"You can update the baggage information of an existing reservation, allowing users to add additional checked bags.\"\n        Example: \"A reservation for ID 'AX37VB' initially has 2 checked bags, the airline agent calls UpdateReservationBaggages to increase the total checked bags to 3.\"\n        \"\"\"\n        \n        # mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # mock other tools function return values \n        reservation = Reservation(reservation_id=\"AX37VB\", user_id=\"user123\", origin=\"SFO\", destination=\"JFK\", flight_type=\"round_trip\", cabin=\"economy\", flights=[], passengers=[], payment_history=[], created_at=(datetime.now() - timedelta(days=1)).strftime(\"%Y-%m-%dT%H:%M:%S\"), total_baggages=2, nonfree_baggages=0, insurance=\"no\", status=None)\n        user = User(user_id=\"user123\", name=Name(first_name=\"John\", last_name=\"Doe\"), address=Address(address1=\"123 Main St\", address2=\"\", city=\"Anytown\", country=\"USA\", state=\"CA\", zip=\"12345\"), email=\"john.doe@example.com\", dob=\"1990-01-01\", payment_methods={\"credit_card_7815826\": CreditCard(source=\"credit_card\", brand=\"visa\", last_four=\"1234\", id=\"7815826\")}, saved_passengers=[], membership=\"regular\", reservations=[\"AX37VB\"])\n\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"AX37VB\" else None\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"user123\" else None\n        \n        #invoke function under test.\n        guard_only_adding_checked_bags_is_allowed(history, api, reservation_id=\"AX37VB\", total_baggages=3, nonfree_baggages=0, payment_id=\"credit_card_7815826\")\n\n    def test_reduce_checked_bags(self):\n        \"\"\"\n        Policy: \"Removing checked bags from the reservation is not permitted.\"\n        Example: \"Updating a reservation to reduce the total number of baggage items from 3 to 2 for reservation ID 'ZFA04Y'.\"\n        \"\"\"\n        \n        # mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # mock other tools function return values \n        reservation = Reservation(reservation_id=\"ZFA04Y\", user_id=\"user456\", origin=\"LAX\", destination=\"ORD\", flight_type=\"one_way\", cabin=\"business\", flights=[], passengers=[], payment_history=[], created_at=(datetime.now() - timedelta(days=1)).strftime(\"%Y-%m-%dT%H:%M:%S\"), total_baggages=3, nonfree_baggages=0, insurance=\"yes\", status=None)\n        user = User(user_id=\"user456\", name=Name(first_name=\"Jane\", last_name=\"Smith\"), address=Address(address1=\"456 Elm St\", address2=\"\", city=\"Othertown\", country=\"USA\", state=\"NY\", zip=\"67890\"), email=\"jane.smith@example.com\", dob=\"1985-05-05\", payment_methods={\"credit_card_123456\": CreditCard(source=\"credit_card\", brand=\"mastercard\", last_four=\"5678\", id=\"123456\")}, saved_passengers=[], membership=\"gold\", reservations=[\"ZFA04Y\"])\n\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"user456\" else None\n        \n        #invoke function under test.\n        with pytest.raises(PolicyViolationException):\n            guard_only_adding_checked_bags_is_allowed(history, api, reservation_id=\"ZFA04Y\", total_baggages=2, nonfree_baggages=0, payment_id=\"credit_card_123456\")\n\n    def test_remove_checked_bags(self):\n        \"\"\"\n        Policy: \"Removing checked bags from the reservation is not permitted.\"\n        Example: \"Despite the user requesting to remove a checked bag, the agent submits a request using UpdateReservationBaggages to change 'total_baggages' from 4 to 3.\"\n        \"\"\"\n        \n        # mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # mock other tools function return values \n        reservation = Reservation(reservation_id=\"5RN9XZ\", user_id=\"user789\", origin=\"MIA\", destination=\"ATL\", flight_type=\"round_trip\", cabin=\"economy\", flights=[], passengers=[], payment_history=[], created_at=(datetime.now() - timedelta(days=1)).strftime(\"%Y-%m-%dT%H:%M:%S\"), total_baggages=4, nonfree_baggages=0, insurance=\"no\", status=None)\n        user = User(user_id=\"user789\", name=Name(first_name=\"Alice\", last_name=\"Johnson\"), address=Address(address1=\"789 Oak St\", address2=\"\", city=\"Sometown\", country=\"USA\", state=\"TX\", zip=\"54321\"), email=\"alice.johnson@example.com\", dob=\"1980-10-10\", payment_methods={\"gift_card_987654\": GiftCard(source=\"gift_card\", amount=100.0, id=\"987654\")}, saved_passengers=[], membership=\"silver\", reservations=[\"5RN9XZ\"])\n\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"5RN9XZ\" else None\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"user789\" else None\n        \n        #invoke function under test.\n        with pytest.raises(PolicyViolationException):\n            guard_only_adding_checked_bags_is_allowed(history, api, reservation_id=\"5RN9XZ\", total_baggages=3, nonfree_baggages=0, payment_id=\"gift_card_987654\")\n\n    def test_adjust_baggage_count_to_zero(self):\n        \"\"\"\n        Policy: \"Removing checked bags from the reservation is not permitted.\"\n        Example: \"An agent mistakenly uses UpdateReservationBaggages and tries to adjust the total baggage count from 2 to 0 for reservation ID 'XJ92KL'.\"\n        \"\"\"\n        \n        # mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # mock other tools function return values \n        reservation = Reservation(reservation_id=\"XJ92KL\", user_id=\"user321\", origin=\"SEA\", destination=\"DEN\", flight_type=\"one_way\", cabin=\"basic_economy\", flights=[], passengers=[], payment_history=[], created_at=(datetime.now() - timedelta(days=1)).strftime(\"%Y-%m-%dT%H:%M:%S\"), total_baggages=2, nonfree_baggages=0, insurance=\"yes\", status=None)\n        user = User(user_id=\"user321\", name=Name(first_name=\"Bob\", last_name=\"Brown\"), address=Address(address1=\"321 Pine St\", address2=\"\", city=\"Newtown\", country=\"USA\", state=\"FL\", zip=\"98765\"), email=\"bob.brown@example.com\", dob=\"1975-03-03\", payment_methods={\"certificate_654321\": Certificate(source=\"certificate\", amount=50.0, id=\"654321\")}, saved_passengers=[], membership=\"regular\", reservations=[\"XJ92KL\"])\n\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"XJ92KL\" else None\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"user321\" else None\n        \n        #invoke function under test.\n        with pytest.raises(PolicyViolationException):\n            guard_only_adding_checked_bags_is_allowed(history, api, reservation_id=\"XJ92KL\", total_baggages=0, nonfree_baggages=0, payment_id=\"certificate_654321\")\n"
        },
        null,
        null
      ]
    },
    "update_reservation_flights": {
      "tool": {
        "tool_name": "update_reservation_flights",
        "policy_items": [
          {
            "name": "Flight Status Restrictions",
            "description": "Flights chosen for booking using ToolX must have the status 'available' to ensure that they have not taken off. Flights with status 'delayed', 'on time', or 'flying' cannot be booked.",
            "references": [
              "If the status is \"available\", the flight has not taken off",
              "If the status is \"delayed\" or \"on time\", the flight has not taken off, cannot be booked.",
              "If the status is \"flying\", the flight has taken off but not landed, cannot be booked."
            ],
            "compliance_examples": [
              "A user requests to book a flight from SFO to LAX on June 20th. The agent checks the flight information and confirms that the flight status is 'available' before proceeding with the booking using the BookReservation tool.",
              "Before booking a round-trip flight for two passengers in economy class, the agent verifies all flights' statuses are 'available' and there are two seats available for this class."
            ],
            "violation_examples": [
              "A user attempts to book a flight to New York on May 16th using the BookReservation tool. However, the flight status indicates 'delayed'.",
              "An agent tries to book a reservation for a user on flight HAT007 from ATL to MIA. The API checks reveal that the flight's status is currently 'flying'.",
              "A reservation request is made for a flight with the status 'on time'.",
              "An agent attempts to book a round-trip from LAX to DFW for a user, but the departure flight's status is 'on time' which is not permissible as per the policy that only allows booking flights with 'available' status.",
              "A reservation is attempted for a flight where the status is 'cancelled'. Despite knowing that only flights with 'available' status can be booked, the agent proceeds, resulting in a policy breach.",
              "A user attempts to make a reservation with two flights. The first one's status is 'delayed', and the second one is 'available'.",
              "A user attempts to make a reservation with two flights. The first one's status is 'available', and the second one is 'delayed'."
            ]
          },
          {
            "name": "Seats Are Available",
            "description": "Flights chosen for booking must have enough available seats for all passengers, and prices listed for booking.",
            "references": [
              "If the status is \"available\", the flight has not taken off, available seats and prices are listed."
            ],
            "compliance_examples": [
              "A user requests to book a flight from SFO to LAX on June 20th in economy class. The flight status is 'available' and there are 21 available seats",
              "A user is booking a round-trip flight from SFO to LAX, for two passengers in economy class. There are enough availble seats in the two flights"
            ],
            "violation_examples": [
              "A user attempts to book a flight to New York on May 16th for 5 passengers in business class, however only 4 seats are available on this flight",
              "An agent attempts to book a round-trip from LAX to DFW for a user in economy cabin, the outgoing flight status is availbale, but the there are no available seat in this cabin",
              "An agent attempts to book a round-trip from LAX to DFW for a user in economy cabin, there are enough seats in the outgoing flight and the flight status is availabile. The return flight status is availbale, but the there are no available seat in this cabin"
            ]
          },
          {
            "name": "Obtain Payment Method for Flight Changes",
            "description": "When updating a flight reservation using the UpdateReservationFlights tool, the agent must ensure that a valid payment method, either a gift card or a credit card stored in the user's profile, is provided for any additional costs or refunds associated with the change.",
            "references": [
              "Payment: If the flights are changed, the user needs to provide one gift card or credit card for payment or refund method.",
              "All payment methods must already be in user profile for safety reasons.",
              "The agent should ask for the payment or refund method instead."
            ],
            "compliance_examples": [
              "An agent is using 'credit_card_1234567', which is present in the user's profile, for handling any potential charges related to the updates.",
              "An agent verifies the availability of 'gift_card_7854421' in the user's profile, ensuring it is prepared for any additional charges."
            ],
            "violation_examples": [
              "An agent updates a reservation using UpdateReservationFlights without confirming that the payment method is stored in the user's profile.",
              "The agent attempts to modify the whole reservation with new flights using the UpdateReservationFlights tool, but does not have any available payment methods.",
              "A customer is attempting to update their flight with additional costs, but did not provide credit or gift cards."
            ]
          },
          {
            "name": "Basic economy flights cannot be modified",
            "description": "Basic economy flights cannot be modified.",
            "references": [
              "Change flights: Basic economy flights cannot be modified."
            ],
            "compliance_examples": [
              "A user requests to update multiple flight segments for their economy reservation.",
              "A user requests to update multiple flight segments for their business class reservation.",
              "A silver user requests to update multiple flight segments for their non-basic-economy reservation.",
              "A gold user requests to change a single flight segment for their business reservation."
            ],
            "violation_examples": [
              "An airline agent tries to call UpdateReservationFlights on a reservation with the cabin class set to 'basic_economy'.",
              "The agent selects a basic economy reservation and attempts to change the flight details modifying the flight segment dates.",
              "A user requests to update one of the flight segments for their basic economy reservation.",
              "A user requests to updates origin and destination for their basic economy reservation.",
              "A user requests to update trip type for their basic economy reservation.",
              "A user requests to updates origin and destination for their non-basic-economy reservation."
            ]
          },
          {
            "name": "Keep the same origin and destination",
            "description": "non-basic-economy reservation can be modified without changing the origin, destination, and trip type. Some flight segments can be kept, but their prices will not be updated based on the current price.",
            "references": [
              "Other reservations can be modified without changing the origin, destination, and trip type. Some flight segments can be kept, but their prices will not be updated based on the current price."
            ],
            "compliance_examples": [
              "change the date of one-way economy reservation.",
              "change the flight of one-way economy reservation, keeping the same origin, destination and date.",
              "change a business classs one way reservation with two flight legs: JFK-LAX, LAX-SFO, to : JFK-SFO.",
              "change an economy classs one way reservation with two flight legs: JFK-LAX, LAX-SFO, to : JFK-TLV, TLV-SFO.",
              "change an economy classs round trip reservation from: JFK-LAX, LAX-JFK, to : JFK-TLV, TLV-JFK."
            ],
            "violation_examples": [
              "a one way trip economy reservation change to anothr flight from a different origin",
              "a one way trip business reservation change to anothr flight to a different destination",
              "change a business reservation with two flights, trip type from one way to round trip",
              "change the orgin of a roundtrip business reservation",
              "change the destination of a roundtrip business reservation",
              "change a roundtrip business reservation to a one way",
              "A gold user requests to updates destination to 'LAX' for their business class reservation.",
              "A user requests to update trip type from 'round-trip' to 'one-way' for their reservation."
            ]
          }
        ]
      },
      "guard_fn_name": "guard_update_reservation_flights",
      "guard_file": {
        "file_name": "airline/update_reservation_flights/guard_update_reservation_flights.py",
        "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\nfrom airline.update_reservation_flights.guard_flight_status_restrictions import guard_flight_status_restrictions\nfrom airline.update_reservation_flights.guard_seats_are_available import guard_seats_are_available\nfrom airline.update_reservation_flights.guard_obtain_payment_method_for_flight_changes import guard_obtain_payment_method_for_flight_changes\nfrom airline.update_reservation_flights.guard_basic_economy_flights_cannot_be_modified import guard_basic_economy_flights_cannot_be_modified\nfrom airline.update_reservation_flights.guard_keep_the_same_origin_and_destination import guard_keep_the_same_origin_and_destination\n\n\ndef guard_update_reservation_flights(history: ChatHistory, api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Checks that a tool call complies to the policies.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n         \n    \"\"\"\n    \n    guard_flight_status_restrictions(history, api, reservation_id, cabin, flights, payment_id)\n    guard_seats_are_available(history, api, reservation_id, cabin, flights, payment_id)\n    guard_obtain_payment_method_for_flight_changes(history, api, reservation_id, cabin, flights, payment_id)\n    guard_basic_economy_flights_cannot_be_modified(history, api, reservation_id, cabin, flights, payment_id)\n    guard_keep_the_same_origin_and_destination(history, api, reservation_id, cabin, flights, payment_id)\n"
      },
      "item_guard_files": [
        {
          "file_name": "airline/update_reservation_flights/guard_flight_status_restrictions.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\n\ndef guard_flight_status_restrictions(history: ChatHistory, api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Policy to check: Flights chosen for booking using ToolX must have the status 'available' to ensure that they have not taken off. Flights with status 'delayed', 'on time', or 'flying' cannot be booked.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n    \"\"\"\n    # Iterate over each flight in the reservation\n    for flight in flights:\n        # Extract flight number and date\n        flight_number = flight['flight_number'] if isinstance(flight, dict) else flight.flight_number\n        date = flight['date'] if isinstance(flight, dict) else flight.date\n\n        # Get the flight status using the API\n        try:\n            status = api.get_flight_status(flight_number, date)\n        except ValueError:\n            raise PolicyViolationException(f\"Flight {flight_number} on {date} not found.\")\n\n        # Check if the flight status is not 'available'\n        if status not in ['available']:\n            raise PolicyViolationException(f\"Flight {flight_number} on {date} has status '{status}' and cannot be booked.\")"
        },
        {
          "file_name": "airline/update_reservation_flights/guard_seats_are_available.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_seats_are_available(history: ChatHistory, api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Policy to check: Flights chosen for booking must have enough available seats for all passengers, and prices listed for booking.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/update_reservation_flights/guard_obtain_payment_method_for_flight_changes.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_obtain_payment_method_for_flight_changes(history: ChatHistory, api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Policy to check: When updating a flight reservation using the UpdateReservationFlights tool, the agent must ensure that a valid payment method, either a gift card or a credit card stored in the user's profile, is provided for any additional costs or refunds associated with the change.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/update_reservation_flights/guard_basic_economy_flights_cannot_be_modified.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\nclass PolicyViolationException(Exception):\n    pass\n\ndef guard_basic_economy_flights_cannot_be_modified(history: ChatHistory, api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Policy to check: Basic economy flights cannot be modified.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n    \n    Raises:\n        PolicyViolationException: If the reservation is in basic economy class and modification is attempted.\n    \"\"\"\n    if cabin == 'basic_economy':\n        raise PolicyViolationException(\"Basic economy flights cannot be modified.\")"
        },
        {
          "file_name": "airline/update_reservation_flights/guard_keep_the_same_origin_and_destination.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_keep_the_same_origin_and_destination(history: ChatHistory, api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Policy to check: non-basic-economy reservation can be modified without changing the origin, destination, and trip type. Some flight segments can be kept, but their prices will not be updated based on the current price.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n    \"\"\"\n    pass #FIXME"
        }
      ],
      "test_files": [
        {
          "file_name": "tests/update_reservation_flights/test_guard_flight_status_restrictions.py",
          "content": "from unittest.mock import MagicMock, patch\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.update_reservation_flights.guard_flight_status_restrictions import guard_flight_status_restrictions\nfrom airline.i_airline import *\nfrom airline.airline_types import *\nfrom datetime import datetime, timedelta\n\nclass TestGuardFlightStatusRestrictions:\n\n    def test_compliance_booking_available_flight(self):\n        \"\"\"\n        Policy: \"Flights chosen for booking using ToolX must have the status 'available'\"\n        Example: \"A user requests to book a flight from SFO to LAX on June 20th. The agent checks the flight information and confirms that the flight status is 'available' before proceeding with the booking using the BookReservation tool.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n        api.get_flight_status.side_effect = lambda flight_number, date: 'available' if flight_number == 'SFO-LAX' and date == '2024-06-20' else None\n\n        # Flight information\n        flights = [FlightInfo(flight_number='SFO-LAX', date='2024-06-20')]\n\n        # Invoke function under test\n        try:\n            guard_flight_status_restrictions(history, api, reservation_id='ZFA04Y', cabin='economy', flights=flights, payment_id='credit_card_7815826')\n        except PolicyViolationException:\n            pytest.fail(\"PolicyViolationException raised unexpectedly for available flight.\")\n\n    def test_violation_booking_delayed_flight(self):\n        \"\"\"\n        Policy: \"Flights with status 'delayed', 'on time', or 'flying' cannot be booked.\"\n        Example: \"A user attempts to book a flight to New York on May 16th using the BookReservation tool. However, the flight status indicates 'delayed'.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n        api.get_flight_status.side_effect = lambda flight_number, date: 'delayed' if flight_number == 'NYC' and date == '2024-05-16' else None\n\n        # Flight information\n        flights = [FlightInfo(flight_number='NYC', date='2024-05-16')]\n\n        # Invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_flight_status_restrictions(history, api, reservation_id='ZFA04Y', cabin='economy', flights=flights, payment_id='credit_card_7815826')\n\n    def test_violation_booking_flying_flight(self):\n        \"\"\"\n        Policy: \"Flights with status 'delayed', 'on time', or 'flying' cannot be booked.\"\n        Example: \"An agent tries to book a reservation for a user on flight HAT007 from ATL to MIA. The API checks reveal that the flight's status is currently 'flying'.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n        api.get_flight_status.side_effect = lambda flight_number, date: 'flying' if flight_number == 'HAT007' and date == '2024-05-16' else None\n\n        # Flight information\n        flights = [FlightInfo(flight_number='HAT007', date='2024-05-16')]\n\n        # Invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_flight_status_restrictions(history, api, reservation_id='ZFA04Y', cabin='economy', flights=flights, payment_id='credit_card_7815826')\n\n    def test_violation_booking_on_time_flight(self):\n        \"\"\"\n        Policy: \"Flights with status 'delayed', 'on time', or 'flying' cannot be booked.\"\n        Example: \"A reservation request is made for a flight with the status 'on time'.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n        api.get_flight_status.side_effect = lambda flight_number, date: 'on time' if flight_number == 'LAX-DFW' and date == '2024-05-16' else None\n\n        # Flight information\n        flights = [FlightInfo(flight_number='LAX-DFW', date='2024-05-16')]\n\n        # Invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_flight_status_restrictions(history, api, reservation_id='ZFA04Y', cabin='economy', flights=flights, payment_id='credit_card_7815826')\n\n    def test_violation_booking_cancelled_flight(self):\n        \"\"\"\n        Policy: \"Flights with status 'delayed', 'on time', or 'flying' cannot be booked.\"\n        Example: \"A reservation is attempted for a flight where the status is 'cancelled'. Despite knowing that only flights with 'available' status can be booked, the agent proceeds, resulting in a policy breach.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n        api.get_flight_status.side_effect = lambda flight_number, date: 'cancelled' if flight_number == 'SFO-JFK' and date == '2024-05-16' else None\n\n        # Flight information\n        flights = [FlightInfo(flight_number='SFO-JFK', date='2024-05-16')]\n\n        # Invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_flight_status_restrictions(history, api, reservation_id='ZFA04Y', cabin='economy', flights=flights, payment_id='credit_card_7815826')\n\n    def test_violation_booking_mixed_status_flights(self):\n        \"\"\"\n        Policy: \"Flights with status 'delayed', 'on time', or 'flying' cannot be booked.\"\n        Example: \"A user attempts to make a reservation with two flights. The first one's status is 'delayed', and the second one is 'available'.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n        api.get_flight_status.side_effect = lambda flight_number, date: 'delayed' if flight_number == 'SFO-JFK' and date == '2024-05-16' else 'available'\n\n        # Flight information\n        flights = [FlightInfo(flight_number='SFO-JFK', date='2024-05-16'), FlightInfo(flight_number='LAX-DFW', date='2024-05-16')]\n\n        # Invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_flight_status_restrictions(history, api, reservation_id='ZFA04Y', cabin='economy', flights=flights, payment_id='credit_card_7815826')\n\n    def test_violation_booking_mixed_status_flights_reverse(self):\n        \"\"\"\n        Policy: \"Flights with status 'delayed', 'on time', or 'flying' cannot be booked.\"\n        Example: \"A user attempts to make a reservation with two flights. The first one's status is 'available', and the second one is 'delayed'.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n        api.get_flight_status.side_effect = lambda flight_number, date: 'available' if flight_number == 'LAX-DFW' and date == '2024-05-16' else 'delayed'\n\n        # Flight information\n        flights = [FlightInfo(flight_number='LAX-DFW', date='2024-05-16'), FlightInfo(flight_number='SFO-JFK', date='2024-05-16')]\n\n        # Invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_flight_status_restrictions(history, api, reservation_id='ZFA04Y', cabin='economy', flights=flights, payment_id='credit_card_7815826')\n"
        },
        null,
        null,
        null,
        null
      ]
    }
  }
}